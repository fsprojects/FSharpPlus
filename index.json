[{"uri":"/FSharpPlus/type-any.html","title":"Any\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nAny\n===\n\nThis is a wrapper type for booleans, with a specific set of monoidal operations.\nThe contained bools would become true only if one of (any) operands are true.\n\nRelated Types\n------------\n\n - [All](type-all.html): Similar wrapper, but using the \u0027all\u0027 criteria.\n\n\nAbstractions\n------------\n\n -  [Semigroup](abstraction-semigroup.html)\n -  [Monoid](abstraction-monoid.html)\n\nExamples\n--------\n*)\n\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\nopen FSharpPlus.Data\n\nlet res1 = Any true \u002B\u002B zero \u002B\u002B Any false\n// val res1 : Any = Any true\n\nlet even x = x % 2 = 0\n\nlet res2 = [2;4;6;7;8] |\u003E map (even \u003E\u003E Any) |\u003E sum\n// val res2 : Any = Any true"},{"uri":"/FSharpPlus/type-nonempty.html","title":"NonEmptyList\u003C\u0027T\u003E\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nNonEmptyList\u003C\u0027T\u003E\n================\n\nA type-safe list that contains at least one element.\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\nopen FSharpPlus.Data\n\n(**\n### Constructing NonEmptyList\n*)\n// you can construct a NonEmptyList by using ofSeq\nlet list123\u0027 = NonEmptyList.create 1 [ 2; 3 ]\n// or more idiomatically\nlet list123 = nelist { 1 ; 2; 3 } // will work in F# version 4.7\n\nlet listOne = NonEmptyList.singleton 1\n// cons\nlet list2 = NonEmptyList.cons 100 list123\n// append two NonEmptyLists\nlet list3 = plus list2 (NonEmptyList.singleton 200)\n// this can be written as (since list2 is a NonEmptyList):\nlet list3\u0027 = plus list2 (result 200)\n// in order to get back to a regular list you can then use toList:\nlet list4 = toList list3\u0027\n\n(**\n### Operations on NonEmptyList\n*)\n\nlet lengthOfList3 = length list3\n\nlet headOf3 = list3.Head\nlet headOf3\u0027 = head list3\n\nlet tailOf3 = list3.Tail"},{"uri":"/FSharpPlus/abstraction-semigroup.html","title":"Semigroup\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n(**\nSemigroup\n=========\nIn mathematics, a semigroup is an algebraic structure consisting of a set together with an associative binary operation. A semigroup generalizes a monoid in that there might not exist an identity element. It also (originally) generalized a group (a monoid with all inverses) to a type where every element did not have to have an inverse, thus the name semigroup.\n___\nMinimal complete definition\n---------------------------\n * \u0060\u0060(\u002B)\u0060\u0060/\u0060\u0060(\u002B\u002B)\u0060\u0060\n*)\n(**\n    static member (\u002B) (x:\u0027Semigroup, y:\u0027Semigroup) :\u0027Semigroup\n*)\n(**\nRules\n-----\n*)\n(**\n    (x \u002B y) \u002B z = x \u002B (y \u002B z)\n*)\n(**\nRelated Abstractions\n--------------------\n - [Monoid](abstraction-monoid.html): A monoid is a Semigroup with an additional \u0060\u0060zero\u0060\u0060 operation\n \n - Alt/MonadPlus: Applicatives/Monads that are also Semigroups/Monoids\n\nConcrete implementations\n------------------------\nFrom .Net/F#\n \n -  \u0060\u0060list\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060option\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060array\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060string\u0060\u0060\n -  \u0060\u0060StringBuilder\u0060\u0060\n -  \u0060\u0060unit\u0060\u0060\n -  \u0060\u0060Set\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Map\u003C\u0027T,\u0027U\u003E\u0060\u0060\n -  \u0060\u0060TimeSpan\u0060\u0060 \n -  \u0060\u0060Tuple\u003C*\u003E\u0060\u0060\n -  \u0060\u0060ValueTuple\u003C*\u003E ( * up to 7 elements)\u0060\u0060\n -  \u0060\u0060\u0027T1* ... *\u0027Tn\u0060\u0060\n -  \u0060\u0060Task\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060ValueTask\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060\u0027T-\u003E\u0027Semigroup\u0060\u0060\n -  \u0060\u0060Async\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Expr\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Lazy\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Dictionary\u003C\u0027T,\u0027U\u003E\u0060\u0060\n -  \u0060\u0060IDictionary\u003C\u0027T,\u0027U\u003E\u0060\u0060\n -  \u0060\u0060IReadOnlyDictionary\u003C\u0027T,\u0027U\u003E\u0060\u0060\n -  \u0060\u0060ResizeArray\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060seq\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060IEnumerator\u003C\u0027T\u003E\u0060\u0060\n \nFrom F#\u002B\n \n -  [\u0060\u0060NonEmptyList\u003C\u0027S\u003E\u0060\u0060](type-nonempty.html)\n -  [\u0060\u0060NonEmptySet\u003C\u0027T\u003E\u0060\u0060](type-nonempty-set.html)\n -  [\u0060\u0060NonEmptyMap\u003C\u0027Key, \u0027T\u003E\u0060\u0060](type-nonempty-map.html)\n -  [\u0060\u0060ZipList\u003C\u0027S\u003E\u0060\u0060](type-ziplist.html)\n -  [\u0060\u0060Dual\u003C\u0027T\u003E\u0060\u0060](type-dual.html)\n -  [\u0060\u0060Endo\u003C\u0027T\u003E\u0060\u0060](type-endo.html)\n -  [\u0060\u0060All\u0060\u0060](type-all.html)\n -  [\u0060\u0060Any\u0060\u0060](type-any.html)\n -  [\u0060\u0060Const\u003C\u0027C,\u0027T\u003E\u0060\u0060](type-const.html)\n -  [\u0060\u0060First\u003C\u0027T\u003E\u0060\u0060](type-first.html)\n -  [\u0060\u0060Last\u003C\u0027T\u003E\u0060\u0060](type-last.html)\n -  [\u0060\u0060DList\u003C\u0027T\u003E\u0060\u0060](type-dlist.html)\n -  [\u0060\u0060Vector\u003C\u0027T,\u0027Dimension\u003E\u0060\u0060](type-vector.html)\n -  [\u0060\u0060Matrix\u003C\u0027T,\u0027Rows,\u0027Columns\u003E\u0060\u0060](type-matrix.html)\n \n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n*)"},{"uri":"/FSharpPlus/type-nonempty-map.html","title":"NonEmptyMap\u003C\u0027Key, \u0027Value\u003E\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nNonEmptyMap\u003C\u0027Key, \u0027Value\u003E\n================\n\nA type-safe map that contains at least one element.\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\nopen FSharpPlus.Data\n\n(**\n### Constructing NonEmptyMap\n*)\n// you can construct a NonEmptyMap by using NonEmptyMap.Create\nlet map1 = NonEmptyMap.Create((\u0022a\u0022, 1), (\u0022b\u0022, 2))\n\nlet map2 = NonEmptyMap.singleton \u0022c\u0022 3\n\n// in order to get back to a regular map you can then use NonEmptyMap.toMap:\nlet map1\u0027 = NonEmptyMap.toMap map1\n\n\n(**\n### Operations on NonEmptyMap\n*)\n\nlet map3 = map1 |\u003E NonEmptyMap.add \u0022d\u0022 4\n\nlet map4 = NonEmptyMap.union map2 map3\n\nmap4 |\u003E NonEmptyMap.tryFind \u0022c\u0022 |\u003E printfn \u0022%A\u0022\n\n"},{"uri":"/FSharpPlus/abstraction-misc.html","title":"Other abstractions\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n(**\nOther abstractions\n==================\n\nHere are some other abstractions, not present in the diagram.\n\n(see the examples)\n\n Examples\n--------\n*)\n\n\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\nopen System\nopen FSharpPlus\nopen FSharpPlus.Data\n\n\n// Indexable\n\nlet namesWithNdx = mapi (fun k v -\u003E \u0022(\u0022 \u002B string k \u002B \u0022)\u0022 \u002B v ) (Map.ofSeq [\u0027f\u0027,\u0022Fred\u0022;\u0027p\u0027,\u0022Paul\u0022])\nlet namesAction = iteri (printfn \u0022(%A)%s\u0022) (Map.ofSeq [\u0027f\u0027,\u0022Fred\u0022;\u0027p\u0027,\u0022Paul\u0022])\nlet res119 = foldi (fun s i t -\u003E t * s - i) 10 [3;4]\nlet res113 = foldi (fun s i t -\u003E t * s - i) 2 [|3;4;5|]\nlet resSomeId20 = traversei (fun k t -\u003E Some (10 \u002B t)) (Tuple 10)\n\n\n// ZipFunctor\n\nlet (x, y) = zip (async { return 1 }) (async { return \u00272\u0027 }) |\u003E Async.RunSynchronously\n\n\n// Collection\n\nlet a = skip 3 [1..10]\nlet b = chunkBy fst [1, \u0022a\u0022; 1, \u0022b\u0022; 2, \u0022c\u0022; 1, \u0022d\u0022]\n\n\n// Reducibles\n\nlet c = nelist {1; 2; 3}\nlet d = reduce (\u002B) c\n\nlet resultList = nelist {Error \u00221\u0022; Error \u00222\u0022; Ok 3; Ok 4; Error \u00225\u0022}\nlet firstOk = choice resultList\n\n\n// Invariant Functor\ntype StringConverter\u003C\u0027t\u003E = StringConverter of (string -\u003E \u0027t) * (\u0027t -\u003E string) with\n    static member Invmap (StringConverter (f, g), f\u0027,g\u0027) = StringConverter (f\u0027 \u003C\u003C f, g \u003C\u003C g\u0027)\n\nlet ofString (StringConverter (f, _)) = f\nlet toString (StringConverter (_, f)) = f\n\nlet floatConv = StringConverter (float\u003Cstring\u003E, string\u003Cfloat\u003E)\n\nlet floatParsed  = ofString floatConv \u00221.8\u0022\nlet floatEncoded = toString floatConv 1.5\n\nlet intConv = invmap int\u003Cfloat\u003E float\u003Cint\u003E floatConv\n\nlet oneParsed  = ofString intConv \u00221\u0022\nlet tenEncoded = toString intConv 10"},{"uri":"/FSharpPlus/type-state.html","title":"State\u003C\u0027S,\u0027T\u003E\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nState\u003C\u0027S,\u0027T\u003E\n============\n\nThe intention when using the State monad is to keep state in a purely functional manner without violating referential transparency of functions.\n\nRelated Types\n------------\n\n - [Reader](type-reader.html): Similar but read-only.\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\nopen FSharpPlus\nopen FSharpPlus.Data\n(**\nFrom [Haskell Wiki on State monad](https://wiki.haskell.org/State_Monad)\n*)\n\nlet rec playGame =\n    function\n    | []-\u003E monad {\n            let! (_, score) = State.get\n            return score\n        }\n    | x::xs-\u003E monad {\n            let! (on, score) = State.get\n            match x with\n            | \u0027a\u0027 when on -\u003E do! State.put (on, score \u002B 1)\n            | \u0027b\u0027 when on -\u003E do! State.put (on, score - 1)\n            | \u0027c\u0027         -\u003E do! State.put (not on, score)\n            | _           -\u003E do! State.put (on, score)\n            return! playGame xs\n        }\n\nlet startState = (false, 0)\nlet moves = toList \u0022abcaaacbbcabbab\u0022\nState.eval (playGame moves) startState\nlet (score, finalState) = State.run (playGame moves) startState"},{"uri":"/FSharpPlus/type-cont.html","title":"Cont\u003C\u0027R,\u0027U\u003E\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nCont\u003C\u0027R,\u0027U\u003E\n===========\n\nThe \u0060Cont\u0060 computation type represents computations which can be interrupted and resumed.\n\nSome of these examples are adapted from [fabriceleal/Continuations on github](https://github.com/fabriceleal/Continuations/blob/master/Continuations/Program.fs).\n\nYou can read up on the style on [Markh Needhams blog post](http://www.markhneedham.com/blog/2009/06/22/f-continuation-passing-style/) or \nby reading [Real World Functional Programming by Tomas Petricek with Jon Skeet](https://livebook.manning.com/book/real-world-functional-programming/chapter-10/156) on the subject.\n\nExamples\n--------\n\nIn order to get an idea about this style, let us contrast some of the examples and how they look in when using F#\u002B or without help.  \n\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\nopen FSharpPlus.Data\n\nlet assertEqual expected actual = \n    if expected \u003C\u003E actual then\n        failwithf \u0022%A != %A\u0022 expected actual\n\n(**\n### Example g k\n\n*)\n\nlet g n = n \u002B 1\nlet f n = g(n \u002B 1) \u002B 1\n\nmodule \u0060\u0060EXAMPLE g k\u0060\u0060 =\n    let g_k n k = k(n \u002B 1)\n    let f_k n k = g_k(n \u002B 1) (fun x -\u003E k(x \u002B 1))\n    f_k 1 (fun x -\u003E assertEqual (f 1) x)\n    f_k 2 (fun x -\u003E assertEqual (f 2) x)\n\n\nmodule \u0060\u0060EXAMPLE g k in FSharpPlus\u0060\u0060 =\n    let g_k n : Cont\u003Cint,int\u003E = monad { return (n \u002B 1) }\n    let f_k n = monad {\n      let! x= g_k(n \u002B 1) \n      return x\u002B1\n    }\n    let n = 2\n    let res = Cont.run (f_k n) id\n    assertEqual (f n) res\n\n\n(**\n### Example Max\n\n*)\n\n// Max, regular-style\nlet max x y =\n    if x \u003E y then x else y\n\nmodule \u0060\u0060EXAMPLE max\u0060\u0060 =\n\n    // Max, CPS-style\n    let max_k x y k =\n        if x \u003E y then k x else k y\n    // More CPS Styl-ish\n    max_k 1 2 (fun x -\u003E assertEqual (max 1 2) x)\n\nmodule \u0060\u0060EXAMPLE max in FSharpPlus\u0060\u0060 =\n    let max_k x y = monad {\n        return if x \u003E y then x else y }\n    let x = Cont.run (max_k 1 2) id\n    assertEqual (max 1 2) x\n\n(**\n### Example factorial\n\n*)\n\n\n// regular factorial\nlet rec factorial n =\n    if n = 0 then\n        1\n    else\n        n * factorial (n-1)\n\nmodule \u0060\u0060EXAMPLE factorial\u0060\u0060 =\n    let rec factorial_k n k =\n        if n = 0 then\n            k 1\n        else\n            factorial_k (n-1) (fun x -\u003E k(x * n))\n\n    let fact_n = 5\n    factorial_k fact_n (fun x -\u003E assertEqual (factorial fact_n) x)\n\nmodule \u0060\u0060EXAMPLE factorial in FSharpPlus\u0060\u0060 =\n    let rec factorial_k n = monad {\n        if n = 0 then\n            return 1\n        else\n            let! x=factorial_k (n-1)\n            return x * n\n      }\n    let fact_n = 5\n    let x = Cont.run (factorial_k fact_n) id\n    assertEqual (factorial fact_n) x\n\n(**\n### Example sum\n\n*)\n\n// sum\nlet rec sum x =\n    if x = 1 then\n        1\n    else\n        sum(x - 1) \u002B x\n\nmodule \u0060\u0060EXAMPLE sum\u0060\u0060 =\n\n    let rec sum_k x k =\n        if x = 1 then\n            k 1\n        else\n            sum_k(x - 1) (fun y -\u003E k(x \u002B y))\n\n    let sum_n = 5\n    sum_k sum_n (fun t -\u003E  assertEqual (sum sum_n) t)\nmodule \u0060\u0060EXAMPLE sum in FSharpPlus\u0060\u0060 =\n\n    let rec sum_k x = monad {\n        if x = 1 then\n            return 1\n        else\n            let! y=sum_k(x - 1)\n            return x \u002B y\n      }\n\n    let sum_n = 5\n    let t = Cont.run (sum_k sum_n) id\n    assertEqual (sum sum_n) t\n\n(**\n### Example Fibonacci number\n\n*)\n\n// fibo\nlet rec fibo n =\n    if n = 0 then\n        1\n    else if n = 1 then\n        1\n        else\n            fibo (n - 1) \u002B fibo (n - 2)\n\nmodule \u0060\u0060EXAMPLE fibo\u0060\u0060 =\n    let rec fibo_k n k =\n        if n = 0 then\n            k 1\n        else if n = 1 then \n            k 1\n            else\n                let k_new1 = (fun x1 -\u003E \n                    let k_new2 = (fun x2 -\u003E k(x1 \u002B x2))\n                    fibo_k (n - 2) k_new2\n                )\n                fibo_k (n - 1) k_new1\n\n    let fibo_n = 9\n    fibo_k fibo_n (fun x -\u003E assertEqual (fibo fibo_n) x)\nmodule \u0060\u0060EXAMPLE fibo in FSharpPlus\u0060\u0060 =\n    let rec fibo_k n =\n      monad {\n        if n = 0 then\n            return 1\n        else if n = 1 then \n            return 1\n            else\n                let! x1 = fibo_k (n - 1)\n                let! x2 = fibo_k (n - 2)\n                return x1\u002Bx2\n      }\n    let fibo_n = 9\n    let x = Cont.run (fibo_k fibo_n) id\n    assertEqual (fibo fibo_n) x\n\n(**\n### Example nth\n\n*)\n\n\n// nth\nlet rec nth n (ls : \u0027a list) =\n    if ls.IsEmpty then\n        None\n    else if n = 0 then\n        Some(ls.Head)\n    else\n        nth (n - 1) ls.Tail\n\nmodule \u0060\u0060EXAMPLE nth\u0060\u0060 =\n\n    let rec nth_k n (ls : \u0027a list) k =\n        if ls.IsEmpty then\n            k(None)\n        else if n = 0 then\n            k(Some(ls.Head))\n        else\n            nth_k (n - 1) ls.Tail k\n    let ls, i1, i2 = [1;2;3;4;5;6], 3, 15\n\n    // becomes:\n    nth_k i1 ls (fun x-\u003EassertEqual (nth i1 ls) x)\n\n    nth_k i2 ls (fun x-\u003EassertEqual (nth i2 ls) x)\n\n\n#nowarn \u00220064\u0022\nmodule \u0060\u0060EXAMPLE nth in FSharpPlus\u0060\u0060 =\n\n    let rec nth_k n (ls : \u0027a list) = monad {\n        if ls.IsEmpty then\n            return (None)\n        else if n = 0 then\n            return (Some(ls.Head))\n        else\n            let! r=nth_k (n - 1) ls.Tail\n            return r\n      }\n    let ls, i1, i2 = [1;2;3;4;5;6], 3, 15\n\n    // becomes:\n    let x = Cont.run (nth_k i1 ls) id\n    assertEqual (nth i1 ls) x\n\n    let x2 = Cont.run (nth_k i2 ls) id\n    assertEqual (nth i2 ls) x2\n\n(**\n### Example count nodes in a tree\n\n*)\n\ntype Tree =\n    | Node of Tree * Tree\n    | Leaf\n// node_count\nlet rec node_count = function\n                    | Node(lt, rt) -\u003E 1 \u002B node_count(lt)  \u002B node_count(rt)\n                    | Leaf -\u003E 0\n\nmodule \u0060\u0060EXAMPLE count_nodes\u0060\u0060 =\n    let rec node_count_k tree k = match tree with\n                                    | Node(ltree, rtree) -\u003E\n                                        let new_k1 = (fun ltree_count -\u003E \n                                            let new_k2 = (fun rtree_count -\u003E \n                                                k(1 \u002B ltree_count \u002B rtree_count)\n                                            )\n                                            node_count_k rtree new_k2\n                                        )\n                                        node_count_k ltree new_k1\n                                    | Leaf -\u003E k 0\n\n    let t = Node(Node(Leaf, Leaf), Node(Leaf, Node(Leaf, Node(Leaf, Leaf))))\n    node_count_k t (fun count -\u003E assertEqual (node_count t)  count)\n\nmodule \u0060\u0060EXAMPLE count_nodes in FSharpPlus\u0060\u0060 =\n    let rec node_count_k tree = \n                                monad {\n                                    match tree with\n                                    | Node(lt, rt) -\u003E \n                                        let! x_lt=node_count_k(lt)\n                                        let! x_rt=node_count_k(rt)\n                                        return 1 \u002B x_lt \u002B x_rt\n                                    | Leaf -\u003E return 0\n                                }\n    let t = Node(Node(Leaf, Leaf), Node(Leaf, Node(Leaf, Node(Leaf, Leaf))))\n    let count = Cont.run (node_count_k t) id\n    assertEqual (node_count t)  count"},{"uri":"/FSharpPlus/type-parallelarray.html","title":"ParallelArray\u003C\u0027T\u003E\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nParallelArray\u003C\u0027T\u003E\n=================\n\nThis type is basically a wrapper over Arrays, which:\n\n - Have a ZipList like applicative implementation.\n - Have parallel processing semantics by default.\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\nopen FSharpPlus\nopen FSharpPlus.Data\n\nlet arr1 = [| 1..100000|]\nlet arr2 = [|10..100000|]\n\nlet arr1_plus_arr2  = (\u002B) \u003C!\u003E parray arr1 \u003C*\u003E parray arr2\n\nopen FSharpPlus.Math.Applicative\n\nlet arr1_plus_arr2\u0027 = parray arr1 .\u002B. parray arr2\nlet arrCombined     = 10 *. parray arr1 .\u002B. parray arr2 .- 5\nlet asMonoid        = Infinite \u0022Hello \u0022 \u003C/plus/\u003E parray [|\u0022City\u0022; \u0022World\u0022; \u0022Sun\u0022|]"},{"uri":"/FSharpPlus/type-listt.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/abstraction-comonad.html","title":"Comonad\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nComonad\n=======\n\nComonads are the categorical dual of monads.\n\n___\n\n\n\nMinimal complete definition\n---------------------------\n\n\n * \u0060\u0060extract s\u0060\u0060\n\n * \u0060\u0060extend g s\u0060\u0060 / \u0060\u0060(=\u003E\u003E) s g\u0060\u0060 \n\n*)\n(**\n    static member Extract (s:\u0027Comonad\u003C\u0027T\u003E) : \u0027T\n    static member (=\u003E\u003E)   (s:\u0027Comonad\u003C\u0027T\u003E, f:\u0027Comonad\u003C\u0027T\u003E -\u003E \u0027U) : Comonad\u003C\u0027U\u003E\n*)\n(**\n\nOther operations\n----------------\n\n * \u0060\u0060duplicate x\u0060\u0060\n*)\n(**\n    static member Duplicate (x : \u0027Comonad\u003C\u0027T\u003E) : \u0027Comonad\u003C\u0027Comonad\u003C\u0027T\u003E\u003E\n*)\n(**\n\n\n\nRules\n-----\n*)\n(**\n    extend extract       = id\n    extract \u003C\u003C extend f  = f\n    extend f \u003C\u003C extend g = extend (f \u003C\u003C extend g)\n*)\n(**\n\n\nRelated Abstractions\n--------------------\n\n - [Monad](abstraction-monad.html): Comonads are the categorical dual of monads.\n\n\nConcrete implementations\n------------------------\n\nFrom .Net/F#\n \n -  \u0060\u0060Async\u003C\u0027T\u003E\u0060\u0060    \n -  \u0060\u0060Lazy\u003C\u0027T\u003E\u0060\u0060     \n -  \u0060\u0060Id\u003C\u0027T\u003E\u0060\u0060       \n -  \u0060\u0060(\u0027W * \u0027T)\u0060\u0060\n -  \u0060\u0060struct (\u0027W * \u0027T)\u0060\u0060\n -  \u0060\u0060\u0027Monoid -\u003E \u0027T\u0060\u0060\n -  \u0060\u0060ValueTask\u003C\u0027T\u003E\u0060\u0060\n \n \nFrom F#\u002B\n\n -  [\u0060\u0060Reader\u003C\u0027R,\u0027T\u003E\u0060\u0060](type-reader.html)\n -  [\u0060\u0060Writer\u003C\u0027Monoid,\u0027T\u003E\u0060\u0060](type-writer.html)\n\n \n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n\n\nExamples\n--------\n\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\nopen FSharpPlus.Data\n\n// A non-empty list\nlet lst   = {Head = 1; Tail = [2;3;4;5]}\n\n// Get the head\nlet elem1 = extract   lst\n\n// Get ALL tails\nlet tails = duplicate lst\n\n// This should return the original list\nlet lst\u0027  = extend extract lst\n\n\n\nlet ct1 = duplicate [1;2;3;4] // val it : List\u003CList\u003Cint\u003E\u003E = [[1; 2; 3; 4]; [2; 3; 4]; [3; 4]; [4]]\nlet ct2 = duplicate (\u0022a\u0022, 10) // val it : string * (string * int) = (\u0022a\u0022, (\u0022a\u0022, 10))\nlet ct3 = duplicate (fun (x:string) -\u003E System.Int32.Parse x)\nlet r80100 = ct3 \u002280\u0022 \u0022100\u0022\n\nlet ct1\u0027 = extend id [1;2;3;4]\nlet ct2\u0027 = extend id (\u0022a\u0022, 10)\nlet ct3\u0027 = extend id (fun (x:string) -\u003E System.Int32.Parse x)\n\nlet ct1\u0027\u0027 = (=\u003E\u003E) [1;2;3;4] id\nlet ct2\u0027\u0027 = (=\u003E\u003E) (\u0022a\u0022, 10) id\nlet ct3\u0027\u0027 = (=\u003E\u003E) (fun (x:string) -\u003E System.Int32.Parse x) id"},{"uri":"/FSharpPlus/abstraction-bitraversable.html","title":"Bitraversable\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nBitraversable\n=============\n\nBitraversable identifies bifunctorial data structures whose elements can be traversed in order, performing Applicative actions at each element, and collecting a result structure with the same shape.\n\nAs opposed to Traversable data structures, which have one variety of element on which an action can be performed, Bitraversable data structures have two such varieties of elements.\n\n___\n\n\n\nMinimal complete definition\n---------------------------\n\n * \u0060\u0060bitraverse f g x\u0060\u0060 | \u0060\u0060bisequence x\u0060\u0060 and \u0060\u0060bimap f g x\u0060\u0060\n*)\n(**\n    static member Bitraverse (t: \u0027Bitraversable\u003C\u0027T1,\u0027U1\u003E, f: \u0027T1-\u003E\u0027Functor\u003C\u0027T2\u003E, g: \u0027U1-\u003E\u0027Functor\u003C\u0027U2\u003E) : \u0027Functor\u003C\u0027Bitraversable\u003C\u0027T2,\u0027U2\u003E\u003E\n    static member Bisequence (t: \u0027Bitraversable\u003C\u0027Functor\u003C\u0027T\u003E,\u0027Functor\u003C\u0027U\u003E\u003E) : \u0027Functor\u003C\u0027Bitraversable\u003C\u0027T,\u0027U\u003E\u003E\n*)\n(**\n\n\n\nRules\n-----\n*)\n(**\n    t \u003C\u003C bitraverse f g = bitraverse (t \u003C\u003C f) (t \u003C\u003C g)\n    bitraverse Identity Identity = Identity\n    bitraverse (Compose \u003C\u003C map g1 \u003C\u003C f1) = Compose \u003C\u003C fmap (bitraverse g1 g21) \u003C\u003C bitraverse f1 f2\n*)\n(**\n\n\nRelated Abstractions\n--------------------\n\n - [Functor](abstraction-functor.html): A bitraversable is generic on the Bitraversable type parameter and the (Applicative) Functor inner type parameter.\n - [Applicative](abstraction-applicative.html): An applicative is a functor whose \u0060\u0060map\u0060\u0060 operation can be splitted in \u0060\u0060return\u0060\u0060 and \u0060\u0060(\u003C*\u003E)\u0060\u0060 operations. \n - [Bifoldable](abstraction-bifoldable.html) : All bitraversables are bifoldables.\n\n\nConcrete implementations\n------------------------\n\nFrom .Net/F#\n\n-  \u0060\u0060\u0027T * \u0027U\u0060\u0060\n-  \u0060\u0060struct (\u0027T * \u0027U)\u0060\u0060\n-  \u0060\u0060Result\u003C\u0027T,\u0027U\u003E\u0060\u0060\n-  \u0060\u0060Choice\u003C\u0027T,\u0027U\u003E\u0060\u0060\n\n\nFrom F#\u002B\n\n -  [\u0060\u0060Const\u003C\u0027C,\u0027T\u003E\u0060\u0060](type-const.html)\n -  [\u0060\u0060Validation\u003C\u0027Error,\u0027T\u003E\u0060\u0060](type-validation.html)\n\n\n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\n\n\nlet asyncSquareRoot x =\n    if x \u003C 0 then \n        Error   (async { printfn \u0022Calc error message\u0022; return \u0022Negative Value\u0022}) \n        else Ok (async { printfn \u0022Calc sqrt of %A\u0022 x ; return sqrt x})\n\nlet res42 = asyncSquareRoot 1764 |\u003E bisequence |\u003E Async.RunSynchronously"},{"uri":"/FSharpPlus/lens.html","title":"Lens\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nLens\n====\n\nLens is an abstraction over function that allow to read and update parts of immutable data.\n\nThe abstraction name comes from the analogy of focusing on a specific part of the data structure.\n\nAnother analogy could be with pointers, but in this case data is treated as immutable which means that instead of modifying it returns a new copy.\n\nIn this [quick tour](tutorial.html#Lens) you can find some basic examples of operating with Lenses.\n\nTo allow lensing over your record types, lens (as functions) have to be written by hand for each field.\n\nAs a convention, all lens identifiers will start with an underscore \u0060_\u0060.\n\nHere\u0027s an example usage of lenses with business objects:\n\n\n*)\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\nopen System\nopen FSharpPlus\n// In order to use the Lens module of F#\u002B we import the following:\nopen FSharpPlus.Lens\n\n// From Mauricio Scheffer: https://gist.github.com/mausch/4260932\ntype Person = \n    { Name: string\n      DateOfBirth: DateTime }\n\nmodule Person =\n    let inline _name f p =\n        f p.Name \u003C\u0026\u003E fun x -\u003E { p with Name = x }\n\ntype Page =\n    { Contents: string }\n\nmodule Page =\n    let inline _contents f p =\n        f p.Contents \u003C\u0026\u003E fun x -\u003E {p with Contents = x}\n\ntype Book = \n    { Title: string\n      Author: Person \n      Pages: Page list }\n\nmodule Book =\n    let inline _author f b =\n        f b.Author \u003C\u0026\u003E fun a -\u003E { b with Author = a }\n\n    let inline _authorName b = _author \u003C\u003C Person._name \u003C| b\n\n    let inline _pages f b =\n        f b.Pages \u003C\u0026\u003E fun p -\u003E { b with Pages = p }\n\n    let inline _pageNumber i b =\n        _pages \u003C\u003C List._item i \u003C\u003C _Some \u003C| b\n\nlet rayuela =\n    { Book.Title = \u0022Rayuela\u0022\n      Author = { Person.Name = \u0022Julio Cort\u00E1zar\u0022\n                 DateOfBirth = DateTime(1914, 8, 26) } \n      Pages = [\n        { Contents = \u0022Once upon a time\u0022 }\n        { Contents = \u0022The End\u0022} ] }\n    \n// read book author name:\nlet authorName1 = view Book._authorName rayuela\n//  you can also write the read operation as:\nlet authorName2 = rayuela ^. Book._authorName\n\n// write value through a lens\nlet book1 = setl Book._authorName \u0022William Shakespear\u0022 rayuela\n// update value\nlet book2 = over Book._authorName String.toUpper rayuela\n\n(**\n\nNote: \n\nThe operator \u0060\u003C\u0026\u003E\u0060 is not available in F#\u002B v1.0 but since it\u0027s a flipped map, you can use \u0060\u003C/flip map/\u003E\u0060 instead.\n\nHowever it\u0027s recommended to upgrade F#\u002B since you\u0027ll get better compile times with \u0060\u003C\u0026\u003E\u0060.\n\nPrism\n=====\n\nAlso called a Partial Lens, they focus in parts of the data that could be there or not.\n\nSee the following example using the built-in \u0060_Some\u0060 prism.\n\n*)\n\ntype Team   = { Name: string; Victories: int }\nlet inline _name      f t = f t.Name      \u003C\u0026\u003E fun n -\u003E { t with Name      = n }\nlet inline _victories f t = f t.Victories \u003C\u0026\u003E fun v -\u003E { t with Victories = v }\n\ntype Player = { Team: Team; Score: int }\nlet inline _team  f p = f p.Team  \u003C\u0026\u003E fun t -\u003E { p with Team  = t }\nlet inline _score f p = f p.Score \u003C\u0026\u003E fun s -\u003E { p with Score = s }\n\ntype Result = { Winner: Player option; Started: bool}\nlet inline _winner   f r = f r.Winner  \u003C\u0026\u003E fun w -\u003E { r with Winner  = w }\nlet inline _started  f r = f r.Started \u003C\u0026\u003E fun s -\u003E { r with Started = s }\n\ntype Match\u003C\u0027t\u003E  = { Players: \u0027t; Finished: bool }\n// For polymorphic updates to be possible, we can\u0027t use \u0060with\u0060 expression on generic field lens.\nlet inline _players  f m = f m.Players  \u003C\u0026\u003E fun p -\u003E { Finished = m.Finished; Players  = p }\nlet inline _finished f m = f m.Finished \u003C\u0026\u003E fun f -\u003E { m with Finished = f }\n\n// Lens composed with Prism -\u003E Prism\nlet inline _winnerTeam x = (_players \u003C\u003C _winner \u003C\u003C _Some \u003C\u003C _team) x\n\n// initial state\nlet match0 =\n    { Players = \n            { Team = { Name = \u0022The A Team\u0022; Victories = 0 }; Score = 0 },\n            { Team = { Name = \u0022The B Team\u0022; Victories = 0 }; Score = 0 }\n      Finished = false }\n\n\n// Team 1 scores\nlet match1 = over (_players \u003C\u003C _1 \u003C\u003C _score) ((\u002B) 1) match0\n\n// Team 2 scores\nlet match2 = over (_players \u003C\u003C _2 \u003C\u003C _score) ((\u002B) 1) match1\n\n// Produce Match\u003CResult\u003E from Match\u003CPlayer * Player\u003E \n// This is possible with these Lenses since they support polymorphic updates.\nlet matchResult0 = setl _players { Winner = None; Started = true } match2\n\n// See if there is a winner by using a prism\nlet _noWinner = preview _winnerTeam matchResult0\n\n// Team 1 scores\nlet match3 = over (_players \u003C\u003C _1 \u003C\u003C _score) ((\u002B) 1) match2\n\n// End of the match\nlet match4 = setl _finished true match3\nlet match5 = over (_players \u003C\u003C _1 \u003C\u003C _team \u003C\u003C _victories) ((\u002B) 1) match4\nlet matchResult1 = over _players (fun (x, _) -\u003E { Winner = Some x; Started = true }) match5\n\n// And the winner is ...\nlet winner = preview _winnerTeam matchResult1\n\n\n\n\n\n\n\n(**\nTraversal\n=========\n\n*)\n\n\n\nlet t1 = [|\u0022Something\u0022; \u0022\u0022; \u0022Something Else\u0022; \u0022\u0022|] |\u003E setl (_all \u0022\u0022) (\u0022Nothing\u0022)\n// val t1 : string [] = [|\u0022Something\u0022; \u0022Nothing\u0022; \u0022Something Else\u0022; \u0022Nothing\u0022|]\n\n// we can preview it\nlet t2 = [|\u0022Something\u0022; \u0022Nothing\u0022; \u0022Something Else\u0022; \u0022Nothing\u0022|] |\u003E preview (_all \u0022Something\u0022)\n// val t2 : string option = Some \u0022Something\u0022\n\n// view all elements in a list\nlet t3 = [|\u0022Something\u0022; \u0022Nothing\u0022; \u0022Something Else\u0022; \u0022Nothing\u0022|] |\u003E toListOf (_all \u0022Something\u0022)\n// val t3 : string list = [\u0022Something\u0022]\n\n// also view it, since string is a monoid\nlet t4 = [|\u0022Something\u0022; \u0022Nothing\u0022; \u0022Something Else\u0022; \u0022Nothing\u0022|] |\u003E view  (_all \u0022Something\u0022)\n// val t4 : string = \u0022Something\u0022\n\n// Lens composed with a Traversal -\u003E Traversal\nlet t5 = [((), \u0022Something\u0022); ((),\u0022\u0022); ((), \u0022Something Else\u0022); ((),\u0022\u0022)] |\u003E preview  (_all ((),\u0022Something\u0022) \u003C\u003C _2)\n// val t5 : Option\u003Cstring\u003E = Some \u0022Something\u0022\n\n\n\n\n(**\nFold\n====\n\n*)\nopen FSharpPlus.Lens\nopen FSharpPlus // This module contain other functions relevant for the examples (length, traverse)\nopen FSharpPlus.Data // Mult\n\nlet f1 = over both length (\u0022hello\u0022,\u0022world\u0022)\n// val f1 : int * int = (5, 5)\n\nlet f2 = (\u0022hello\u0022,\u0022world\u0022)^.both\n// val f2 : string = \u0022helloworld\u0022\n\nlet f3 = anyOf both ((=)\u0027x\u0027) (\u0027x\u0027,\u0027y\u0027)\n// val f3 : bool = true\n\nlet f4 = (1,2)^..both\n// val f4 : int list = [1; 2]\n\nlet f5 = over items length [\u0022hello\u0022;\u0022world\u0022]\n// val f5 : int list = [5; 5]\n\nlet f6 = [\u0022hello\u0022;\u0022world\u0022]^.items\n// val f6 : string = \u0022helloworld\u0022\n\nlet f7 = anyOf items ((=)\u0027x\u0027) [\u0027x\u0027;\u0027y\u0027]\n// val f7 : bool = true\n\nlet f8 = [1;2]^..items\n// val f8 : int list = [1; 2]\n\nlet f9 = foldMapOf (traverse \u003C\u003C both \u003C\u003C _Some) Mult [(Some 21, Some 21)]\n// val f9 : Mult\u003Cint\u003E = Mult 441\n\nlet f10 = foldOf (traverse \u003C\u003C both \u003C\u003C _Some) [(Some 21, Some 21)]\n// val f10 : int = 42\n\nlet f11 = allOf both (fun x-\u003E x \u003E= 3) (4,5)\n// val f11 : bool = true\n\n(**\nIso\n===\n\n*)\n\n\nlet toOption (isSome, v) = if isSome then Some v else None\nlet fromOption = function Some (x:\u0027t) -\u003E (true, x) | None -\u003E (false, Unchecked.defaultof\u003C\u0027t\u003E)\nlet inline isoTupleOption x = x |\u003E iso toOption fromOption\n\n\nlet i1 = view isoTupleOption (System.Int32.TryParse \u002242\u0022)\n// val i1 : int option = Some 42\n\nlet i2 = view (from\u0027 isoTupleOption) (Some 42)\n// val i2 : bool * int = (true, 42)\n\n// Iso composed with a Lens -\u003E Lens\nlet i3 = view (_1 \u003C\u003C isoTupleOption) (System.Int32.TryParse \u002242\u0022, ())\n// val i3 : int option = Some 42\n\n\n(**\nMaximum and minimum\n===================\n\n*)\n\nlet fv3 = maximumOf (traverse \u003C\u003C both \u003C\u003C _Some) [(Some 1, Some 2);(Some 3,Some 4)]\n// val fv3 : int option = Some 4\n\nlet fv4 = minimumOf (traverse \u003C\u003C both \u003C\u003C _Some) [(Some 1, Some 2);(Some 3,Some 4)]\n// val fv4 : int option = Some 1"},{"uri":"/FSharpPlus/index.html","title":"FSharpPlus\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nFSharpPlus\n======================\nF#\u002B is a base library that aims to take F# to the next level of functional\nprogramming. \n\n*What if we imagine F# as more than it is?*\n\nF#\u002B builds upon FSharp, using generic programming techniques to help\nyou avoid boiler plate code.  However, by naming conventions and signatures\nit can be seen to \u0027enhance\u0027 rather than \u0027replace\u0027 existing patterns as much\nas possible.\n\nThe additions can be summarised as:\n\n * [Extensions](extensions.html) to core types, such as [\u0060String.toLower\u0060](reference/fsharpplus-string.html)\n\n * [Generic Functions and Operators](generic-doc.html) like \u0060map\u0060, which can be extended to support other types\n\n * Generic and customizable [Computation Expressions](computation-expressions.html),\n   like \u0060monad\u0060\n\n * A generic [Math Module](numerics.html)\n\n * [Abstractions](abstractions.html) that capture common FP patterns, such as\n   the standard monads Cont, Reader, Writer, State and their Monad Transformers\n\n * Some new types that work well with the abstractions, such as NonEmptyList,\n   DList and Validation\n\n * A polymorphic [Lenses/Optics](tutorial.html#Lens) to easily read and update\n   parts of immutable data\n\n * Generic methods that help you with [parsing](parsing.html)\n\nNote, however, that F#\u002B does not go into solving a specific thing for a specific\ntechnology, such as JSON parsing.\n\nSome functions are available as [extension methods](extension-methods.html)\nso are callable from C#. Note that this is not complete, or currently considered high priority.\n\nGetting started is easy since you can start with enjoying some of the extensions\nand generic functions, but you will find other parts of F#\u002B unfold before you\nand become useful the deeper in you get.\n\nExample 1\n---------\n\nThis example demonstrates using an extension function defined in this library.\n\n*)\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\nopen FSharpPlus\n\nlet x = String.replace \u0022old\u0022 \u0022new\u0022 \u0022Good old days\u0022\n// val x : string = \u0022Good new days\u0022\n\n(**\n\nExample 2\n---------\n\nThis example demonstrates using a generic function defined in this library.\n\n*)\n\nmap string [|2;3;4;5|]\n// val it : string [] = [|\u00222\u0022; \u00223\u0022; \u00224\u0022; \u00225\u0022|]\n\nmap ((\u002B) 9) (Some 3)\n// val it : int option = Some 12\n\nopen FSharpPlus.Data\n\nmap string (NonEmptyList.create 2 [3;4;5])\n// val it : NonEmptyList\u003Cstring\u003E = {Head = \u00222\u0022; Tail = [\u00223\u0022; \u00224\u0022; \u00225\u0022];}\n\n(**\n\nFor a more hands on run through F#\u002B we recommend following the tutorial:\n\n * [Tutorial](tutorial.html) contains a further explanation of this library.\n\n\nReference Documentation\n-----------------------\n\n * [Types](types.html) contains detailed information about all the types provided in this library.\n\n * [API Reference](reference/index.html) contains automatically generated documentation for all types, modules\n   and functions in the library. This includes additional brief samples on using most of the\n   functions.\n\nSamples\n-----------------------\n\nThis documentation is automatically generated from \u0060*.fsx\u0060 files in [the content folder][content]. \nIt can be useful to clone a local copy to review.\n\nThe [API reference](reference/index.html) is automatically generated from\nMarkdown comments in the library implementation.\n \nAlso of note is the [Sample folder][samples]\nwhich contains sample scripts showing how to use F#\u002B in your code.\n\nContributing and copyright\n--------------------------\n\nThe project is hosted on [GitHub][gh] where you can [report issues][issues], fork \nthe project and submit pull requests.\n\nIf you\u0027re adding a new public API, please also consider adding [documentation][content].\nYou might also want to read the [library design notes][design] to understand how it works.\n\nThe library is available under Apache License, Version 2.0, which allows modification and \nredistribution for both commercial and non-commercial purposes. For more information see the \n[License file][license] in the GitHub repository. \n\n  [content]: https://github.com/fsprojects/FSharpPlus/tree/master/docsrc/content\n  [samples]: https://github.com/fsprojects/FSharpPlus/tree/master/src/FSharpPlus.Docs/Samples\n  [gh]: https://github.com/fsprojects/FSharpPlus\n  [issues]: https://github.com/fsprojects/FSharpPlus/issues\n  [readme]: https://github.com/fsprojects/FSharpPlus/blob/master/README.md\n  [license]: https://github.com/fsprojects/FSharpPlus/blob/master/LICENSE.txt\n  [design]: https://github.com/fsprojects/FSharpPlus/blob/master/DESIGN_GUIDELINES.md\n*)"},{"uri":"/FSharpPlus/abstraction-category.html","title":"Category\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n(**\nCategory\n========\n\nA category has an id and a composition operation.\n\n___\n\n\n\nMinimal complete definition\n---------------------------\n\n\n * \u0060\u0060catId\u0060\u0060\n\n * \u0060\u0060catComp f g\u0060\u0060 / \u0060\u0060(\u003C\u003C\u003C)\u0060\u0060 f g\n\n*)\n(**\n    static member get_Id() : \u0027Category\u003C\u0027T,\u0027T\u003E\n    static member (\u003C\u003C\u003C) (f:Category\u003C\u0027U,\u0027V\u003E, g:\u0027Category\u003C\u0027T,\u0027U\u003E) : \u0027Category\u003C\u0027T,\u0027V\u003E\n*)\n(**\n\n\n\nOther operations\n----------------\n\n * \u0060\u0060(\u003E\u003E\u003E)\u0060\u0060\n*)\n(**\n    static member (\u003E\u003E\u003E) (g:\u0027Category\u003C\u0027T,\u0027U\u003E, f:Category\u003C\u0027U,\u0027V\u003E) : \u0027Category\u003C\u0027T,\u0027V\u003E\n*)\n(**\n\n\n\nRules\n-----\n*)\n(**\n    catId \u003C\u003C\u003C f = f \u003C\u003C\u003C catId = f\n*)\n(**\n\n\nConcrete implementations\n------------------------\n\nFrom .Net/F#\n \n -  \u0060\u0060\u0027T-\u003E\u0027U\u0060\u0060\n -  \u0060\u0060Func\u003C\u0027T,\u0027U\u003E\u0060\u0060\n\n \nFrom F#\u002B\n\n -  [\u0060\u0060Kleisli\u003C\u0027T, \u0027Monad\u003C\u0027U\u003E\u003E\u0060\u0060](type-kleisli.html)\n\n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n*)"},{"uri":"/FSharpPlus/type-optiont.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/type-choicet.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/type-writert.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/abstraction-monoid.html","title":"Monoid\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nMonoid\n======\nTypes with an associative binary operation that has an identity.\n___\nMinimal complete definition\n---------------------------\n * \u0060zero\u0060\u0060\n * \u0060\u0060(\u002B) x y\u0060\u0060/\u0060\u0060(\u002B\u002B) x y\u0060\u0060\n*)\n(**\n    static member get_Zero () :\u0027Monoid\n    static member (\u002B) (x:\u0027Monoid, y:\u0027Monoid) :\u0027Monoid\n*)\n(**\nOther operations\n----------------\n * \u0060\u0060Seq.sum\u0060\u0060\n*)\n(**\n    static member Sum (x:Seq\u003C\u0027Monoid\u003E) :\u0027Monoid\n*)\n(**\nRules\n-----\n*)\n(**\n\tzero \u002B x = x\n    x \u002B zero = x\n    (x \u002B y) \u002B z = x \u002B (y \u002B z)\n    Seq.sum = Seq.fold (\u002B) zero\n    sum = fold (\u002B) zero (generic to all foldables)\n*)\n(**\nRelated Abstractions\n--------------------\n - [Semigroup](abstraction-semigroup.html): A monoid is a Semigroup with an additional \u0060\u0060zero\u0060\u0060 operation\n \n - [Alternative / MonadPlus](abstraction-alternative.html): Applicatives/Monads that are also Monoids. Though their monoidal definition could be different.\n\n\nConcrete implementations\n------------------------\nFrom .Net/F#\n \n -  \u0060\u0060list\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060option\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060array\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060string\u0060\u0060\n -  \u0060\u0060StringBuilder\u0060\u0060\n -  \u0060\u0060unit\u0060\u0060\n -  \u0060\u0060Set\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Map\u003C\u0027T,\u0027Monoid\u003E\u0060\u0060\n -  \u0060\u0060TimeSpan\u0060\u0060 \n -  \u0060\u0060Tuple\u003C\u0027Monoid1* ... *\u0027MonoidN\u003E\u0060\u0060\n -  \u0060\u0060\u0027Monoid1* ... *\u0027MonoidN\u0060\u0060\n -  \u0060\u0060Task\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060ValueTask\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060\u0027T-\u003E\u0027Monoid\u0060\u0060\n -  \u0060\u0060Async\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Expr\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Lazy\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Dictionary\u003C\u0027T,\u0027Monoid\u003E\u0060\u0060\n -  \u0060\u0060IDictionary\u003C\u0027T,\u0027Monoid\u003E\u0060\u0060\n -  \u0060\u0060IReadOnlyDictionary\u003C\u0027T,\u0027Monoid\u003E\u0060\u0060\n -  \u0060\u0060ResizeArray\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060seq\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060IEnumerator\u003C\u0027T\u003E\u0060\u0060\n \nFrom F#\u002B\n \n -  [\u0060\u0060ZipList\u003C\u0027T\u003E\u0060\u0060](type-ziplist.html)\n -  [\u0060\u0060Dual\u003C\u0027T\u003E\u0060\u0060](type-dual.html)\n -  [\u0060\u0060Endo\u003C\u0027T\u003E\u0060\u0060](type-endo.html)\n -  [\u0060\u0060All\u0060\u0060](type-all.html)\n -  [\u0060\u0060Any\u0060\u0060](type-any.html)\n -  [\u0060\u0060Const\u003C\u0027T,\u0027U\u003E\u0060\u0060](type-const.html)\n -  [\u0060\u0060First\u003C\u0027T\u003E\u0060\u0060](type-first.html)\n -  [\u0060\u0060Last\u003C\u0027T\u003E\u0060\u0060](type-last.html)\n -  [\u0060\u0060DList\u003C\u0027T\u003E\u0060\u0060](type-dlist.html)\n -  [\u0060\u0060Vector\u003C\u0027T,\u0027Dimension\u003E\u0060\u0060](type-vector.html)\n -  [\u0060\u0060Matrix\u003C\u0027T,\u0027Rows,\u0027Columns\u003E\u0060\u0060](type-matrix.html)\n\n \n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\nopen FSharpPlus.Math.Generic\nopen FSharpPlus.Data\n\n\n/// A monoid that represents results of comparisons\ntype Ordering = LT|EQ|GT with\n    static member        Zero = EQ\n    static member        (\u002B) (x:Ordering, y) = \n        match x, y with\n        | LT, _ -\u003E LT\n        | EQ, a -\u003E a\n        | GT, _ -\u003E GT\n\nlet inline compare\u0027 x y =\n    match compare x y with\n    | a when a \u003E 0 -\u003E GT\n    | a when a \u003C 0 -\u003E LT\n    | _            -\u003E EQ\n\nlet resGreater = compare\u0027 7 6\n\n/// A monoid of all numbers from 0 to 4\ntype Mod5 = Mod5 of uint32 with\n    static member inline get_Zero() = Mod5 0u\n    static member inline (\u002B) (Mod5 x, Mod5 y) = Mod5 ( (x \u002B y) % 5u)\nlet Mod5 x = Mod5 (x % 5u)\n\n\n// Results of Monoid operations\nlet emptyLst:list\u003Cint\u003E = zero\nlet zeroUint:Mod5   = zero\nlet res1 = zero \u002B\u002B Mod5 11u\nlet res2  = sum \u003C| map Mod5 [4u; 2u; 1u]\nlet res3  = sum [zero; Mod5 2G; Mod5 6G]\nlet res8n4 = [zero; [8;4]]\nlet res15 = Mult 15 \u002B\u002B zero\nlet resTrue = sum [zero; Any true]\nlet resFalse = sum (map All [true;false])\nlet resHi = zero \u002B\u002B \u0022Hi\u0022\nlet resGT = zero \u002B\u002B  GT\nlet resLT = sum [zero; LT ; EQ ;GT]\nlet res9823 = sum (map Dual [zero;\u00223\u0022;\u00222\u0022;\u00228\u0022;\u00229\u0022])\nlet resBA = Dual \u0022A\u0022 \u002B\u002B Dual \u0022B\u0022 \nlet resEl00:list\u003Cint\u003E*float = zero\nlet resS3P20     = (1G, Mult 5.0) \u002B\u002B  (2, Mult 4G)\nlet res230       = (zero,zero) \u002B\u002B ([2],[3.0])\nlet res243       = ([2;4],[3]) \u002B\u002B zero\nlet res23        = zero \u002B\u002B ([2],\u00223\u0022)\nlet resLtDualGt  =  (LT,Dual GT) \u002B\u002B zero\nlet res230hiSum2 = (zero, zero, 2) \u002B\u002B ([2], ([3.0], \u0022hi\u0022), zero)\nlet res230hiS4P3 = (zero, zero   ) \u002B\u002B ([2], ([3.0], \u0022hi\u0022, 4, Mult (6 % 2)))\nlet tuple5 :string*(Any*string)*(All*All*All)*int*string = zero"},{"uri":"/FSharpPlus/type-readert.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\nopen FSharpPlus"},{"uri":"/FSharpPlus/type-first.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/extension-methods.html","title":"Extension Methods\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\nopen FSharpPlus\n\n(**\nExtension Methods\n=================\n\n*)\n\n(**\n\nSome methods are also exposed as extensions. This makes possible some uses from C#\n\nHere are some examples:\n\n*)\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\nopen FSharpPlus.Extensions\n\nlet opt  = Option.Sequence [Some 1; Some 2]\nlet asn = Async.Sequence [| async {return 1}; async {return 2} |]"},{"uri":"/FSharpPlus/abstraction-bifoldable.html","title":"Bifoldable\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n(**\nBifoldable\n=======\n\nIntuitively a bifoldable is a type with 2 arguments, each of them being foldable.\n\n___\n\nA bifoldable (short for binary foldable) or foldable of two variables is a container of up to two elements whose components can be folded to a single value.\n\nUnlike bimap which preserves the container type, bifoldable will extract and fold the value.\n\n\nMinimal complete definition\n---------------------------\n\n\n * \u0060\u0060bifoldMap f g x\u0060\u0060\n*)\n(**\n    static member BifoldMap (x:\u0027Bifoldable\u003C\u0027T,\u0027V\u003E, f:\u0027T-\u003E\u0027U, g:\u0027V-\u003E\u0027U) :\u0027U\n*)\n(**\n\n* \u0060\u0060bifold f g z x\u0060\u0060\n*)\n(**\n    static member Bifold (x:\u0027Bifoldable\u003C\u0027T,\u0027V\u003E, f:\u0027T-\u003E\u0027Monoid, g:\u0027V-\u003E\u0027Monoid, z: \u0027Monoid) :\u0027Monoid\n*)\n(**\n\n* \u0060\u0060bifoldBack f g x z\u0060\u0060\n*)\n(**\n    static member BifoldBack (x:\u0027Bifoldable\u003C\u0027T,\u0027V\u003E, f:\u0027T-\u003E\u0027Monoid, g:\u0027V-\u003E\u0027Monoid, z: \u0027Monoid) :\u0027Monoid\n*)\n(**\n\n\nOther operations\n----------------\n\n * \u0060\u0060bisum x\u0060\u0060\n*)\n(**\n    static member Bisum (x:Bifunctor\u003C\u0027T,\u0027T\u003E) :\u0027T\n*)\n\n(**\n\n\n\n\nRules\n-----\n*)\n(**\n    bisum x = bifoldMap id id x\n    bifoldMap f g x = bifoldBack (f \u003E\u003E (\u002B\u002B)) (g \u003E\u003E (\u002B\u002B)) x zero\n    bifoldBack f g x z = Endo.run (bifoldMap (f \u003E\u003E Endo) (g \u003E\u003E Endo) x) z\n*)\n(**\n\n\nRelated Abstractions\n--------------------\n\n - [Foldable](abstraction-foldable.html): All bifoldable contain up to two elements that are foldable to a single common type.\n - [Monoid](abstraction-monoid.html): For containers where the two elements are not disjoint, the same relation that foldable has to monoid applies.\n\nConcrete implementations\n------------------------\n\nFrom .Net/F#\n \n -  \u0060\u0060\u0027T * \u0027U\u0060\u0060\n -  \u0060\u0060struct (\u0027T * \u0027U)\u0060\u0060\n -  \u0060\u0060Result\u003C\u0027T,\u0027U\u003E\u0060\u0060\n -  \u0060\u0060Choice\u003C\u0027T,\u0027U\u003E\u0060\u0060\n\n \nFrom F#\u002B\n\n -  [\u0060\u0060Const\u003C\u0027C,\u0027T\u003E\u0060\u0060](type-const.html)\n -  [\u0060\u0060Validation\u003C\u0027err,\u0027a\u003E\u0060\u0060](type-validation.html)\n\n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n\nExamples\n--------\n*)\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\nopen FSharpPlus\nopen FSharpPlus.Control\n\nlet listMapSeqLength = List.map Seq.length\nlet listMapTimes2 = List.map ((*) 2)\n\nlet c1 : Choice\u003Cint list,string list\u003E = Choice1Of2 [1..2]\nlet c2 : Choice\u003Cint list,string list\u003E = Choice2Of2 [\u0022a\u0022;\u0022bbbb\u0022]\n\nbifoldBack (listMapSeqLength \u003E\u003E (\u002B\u002B)) (listMapTimes2 \u003E\u003E (\u002B\u002B)) c1 [0] // = [2;4;0]\nbifoldBack (listMapSeqLength \u003E\u003E (\u002B\u002B)) (listMapTimes2 \u003E\u003E (\u002B\u002B)) c2 [0] // = [1;4;0]\nbifoldMap listMapSeqLength listMapTimes2 c1 // = [2;4]\nbifoldMap listMapSeqLength listMapTimes2 c2 // = [1;4]\n\nlet t = (\u0022b\u0022,\u0022c\u0022)\nbifoldBack (\u002B\u002B) (\u002B\u002B) t \u0022a\u0022 // = \u0022bca\u0022\nbifold (\u002B\u002B) (\u002B\u002B) \u0022a\u0022 t // = \u0022abc\u0022\n\n// implementing on custom type:\ntype MyEither\u003C\u0027a,\u0027b\u003E = \n    | MyLeft of \u0027a \n    | MyRight of \u0027b\n    static member inline BifoldMap (x: MyEither\u003C_,_\u003E, f, g) =\n      match x with\n      | MyLeft a -\u003E f a\n      | MyRight a -\u003E g a\n\n    static member BifoldBack (x: MyEither\u003C_,_\u003E, f, g, z) =\n        match x with\n        | MyLeft a -\u003E f a z\n        | MyRight a -\u003E g a z\n\nbisum (MyEither.MyLeft \u0022a\u0022) // = \u0022a\u0022\nbisum (1,2) // = 3\n\n\nlet inline law1 x =\n  bisum x = bifoldMap id id x\n\nlaw1 (1,1) // = true\nlaw1 (Ok [1;2;3]) // = true\nlaw1 (Error [1;2;3]) // = true\nlaw1 (Choice1Of2 [1;2;3]) // = true\nlaw1 (Choice2Of2 [1;2;3]) // = true\nlaw1 (MyLeft [1;2;3]) // = true\nlaw1 (MyRight [1;2;3]) // = true\n\n\nlet inline law2 x f g =\n  bifoldMap f g x = bifoldBack (f \u003E\u003E (\u002B\u002B)) (g \u003E\u003E (\u002B\u002B)) x zero\n\nlaw2 (1,1) ((\u002B) 1) ((\u002B) 2) // = true\nlaw2 (Ok [1;2;3]) ((\u002B\u002B) [1]) ((\u002B\u002B) [2]) // = true\nlaw2 (\u0022a\u0022,\u0022b\u0022) ((\u002B) \u0022bbbb\u0022) ((\u002B) \u0022aaaa\u0022) // = true\n\nopen FSharpPlus.Data\nlet inline law3 x f g z =\n  bifoldBack f g x z = Endo.run (bifoldMap (f \u003E\u003E Endo) (g \u003E\u003E Endo) x) z\n\nlaw3 (1,1) (\u002B\u002B) (\u002B\u002B) 5 // = true\nlaw3 (\u0022a\u0022,\u0022b\u0022) (\u002B\u002B) (\u002B\u002B) \u0022abcd\u0022 // = true\nlaw3 (Ok [1;2;3]) (\u002B\u002B) (\u002B\u002B) [0;1;2;3;4] // = true"},{"uri":"/FSharpPlus/abstraction-monad.html","title":"Monad\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nMonad\n=====\n\nDefines the basic operations over a monad, a concept from a branch of mathematics known as category theory. From the perspective of an F# programmer, however, it is best to think of a monad as an abstract datatype of actions. F#\u002B generic computation expressions provide a convenient syntax for writing monadic expressions.\n\n___\n\n\n\nMinimal complete definition\n---------------------------\n\n\n * \u0060\u0060return x\u0060\u0060/\u0060\u0060result x\u0060\u0060\n * \u0060\u0060(\u003E\u003E=) x f\u0060\u0060\n*)\n(**\n    static member Return (x: \u0027T) : \u0027Monad\u003C\u0027T\u003E\n    static member (\u003E\u003E=) (x: Monad\u003C\u0027T\u003E, f: \u0027T-\u003EMonad\u003C\u0027U\u003E) : Monad\u003C\u0027U\u003E\n*)\n(**\n\nNote: \u0060\u0060return\u0060\u0060 can\u0027t be used outside computation expressions, use \u0060\u0060result\u0060\u0060 instead.\n\nOther operations\n----------------\n\n * \u0060\u0060join\u0060\u0060\n*)\n(**\n    static member Join (x:\u0027Monad\u003C\u0027Monad\u003C\u0027T\u003E\u003E) :\u0027Monad\u003C\u0027T\u003E\n*)\n(**\n\n\n\nRules\n-----\n*)\n(**\n    return a \u003E\u003E= k = k a\n    m \u003E\u003E= return = m\n    m \u003E\u003E= (fun x -\u003E k x \u003E\u003E= h) = (m \u003E\u003E= k) \u003E\u003E= h\n*)\n(**\n\n\nRelated Abstractions\n--------------------\n\n - [Functor](abstraction-functor.html): Monads are automatically functors.\n \n - [Applicative](abstraction-applicative.html) : Monads are automatically applicatives.\n\n\nConcrete implementations\n------------------------\n\nFrom F#\n \n -  \u0060\u0060seq\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060list\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060array\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060option\u003C\u0027T\u003E\u0060\u0060 \n -  \u0060\u0060voption\u003C\u0027T\u003E\u0060\u0060 \n -  \u0060\u0060Lazy\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Async\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Result\u003C\u0027T,\u0027U\u003E\u0060\u0060 \n -  \u0060\u0060Choice\u003C\u0027T,\u0027U\u003E\u0060\u0060\n -  \u0060\u0060\u0027Monoid * \u0027T\u0060\u0060\n -  \u0060\u0060struct (\u0027Monoid * \u0027T)\u0060\u0060\n -  \u0060\u0060Task\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060ValueTask\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060\u0027R-\u003E\u0027T\u0060\u0060\n -  \u0060\u0060ResizeArray\u003C\u0027T\u003E\u0060\u0060\n\n \nFrom F#\u002B\n\n -  [\u0060\u0060Identity\u003C\u0027T\u003E\u0060\u0060](type-identity.html)\n -  [\u0060\u0060Cont\u003C\u0027R,\u0027T\u003E\u0060\u0060](type-cont.html)\n -  [\u0060\u0060ContT\u003C\u0027R,\u0027T\u003E\u0060\u0060](type-contt.html)\n -  [\u0060\u0060Reader\u003C\u0027R,\u0027T\u003E\u0060\u0060](type-reader.html)\n -  [\u0060\u0060ReaderT\u003C\u0027R,\u0027Monad\u003C\u0027T\u003E\u003E\u0060\u0060](type-readert.html)\n -  [\u0060\u0060Writer\u003C\u0027Monoid,\u0027T\u003E\u0060\u0060](type-writer.html)\n -  [\u0060\u0060WriterT\u003C\u0027Monad\u003C\u0027T * \u0027Monoid\u003E\u003E\u0060\u0060](type-writert.html)\n -  [\u0060\u0060State\u003C\u0027S,\u0027T * \u0027S\u003E\u0060\u0060](type-state.html)\n -  [\u0060\u0060StateT\u003C\u0027S,\u0027Monad\u003C\u0027T * \u0027S\u003E\u003E\u0060\u0060](type-statet.html)\n -  [\u0060\u0060OptionT\u003C\u0027Monad\u003Coption\u003C\u0027T\u003E\u003E\u0060\u0060](type-optiont.html)\n -  [\u0060\u0060ValueOptionT\u003C\u0027Monad\u003Cvoption\u003C\u0027T\u003E\u003E\u0060\u0060](type-valueoptiont.html)\n -  [\u0060\u0060SeqT\u003C\u0027Monad\u003Cseq\u003C\u0027T\u003E\u003E\u0060\u0060](type-seqt.html)\n -  [\u0060\u0060ListT\u003C\u0027Monad\u003Clist\u003C\u0027T\u003E\u003E\u0060\u0060](type-listt.html)\n -  [\u0060\u0060ResultT\u003C\u0027Monad\u003CResult\u003C\u0027T,\u0027TError\u003E\u003E\u0060\u0060](type-resultt.html)\n -  [\u0060\u0060ChoiceT\u003C\u0027Monad\u003CChoice\u003C\u0027T,\u0027TError\u003E\u003E\u0060\u0060](type-choicet.html)\n -  [\u0060\u0060Free\u003C\u0027Functor\u003C\u0027T\u003E,\u0027T\u003E\u0060\u0060](type-free.html)\n -  [\u0060\u0060NonEmptyList\u003C\u0027T\u003E\u0060\u0060](type-nonempty.html)\n -  [\u0060\u0060DList\u003C\u0027T\u003E\u0060\u0060](type-dlist.html)\n \n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n\n\nExamples\n--------\n\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\nopen FSharpPlus.Data\n\n\n// Monads allow us to use our generic computation expressions\n\n// This will return the list [11;21;12;22] which is both lists combined in different ways with the (\u002B) operation\nlet lst11n21n12n22 =\n    monad {\n        let! x1 = [1;   2]\n        let! x2 = [10; 20]\n        return ((\u002B) x1 x2) }\n\n// This is the same example but with a non-empty list\nlet neLst11n21n12n22 = \n    monad {\n        let! x1 = { NonEmptyList.Head =  1; Tail =  [2] }\n        let! x2 = { NonEmptyList.Head = 10; Tail = [20] }\n        return ((\u002B) x1 x2)}\n\n// And now an example with options\nlet some14 =\n    monad {\n        let! x1 = Some 4\n        let! x2 = tryParse \u002210\u0022\n        return ((\u002B) x1 x2) }\n\n\n\n// MONAD TRANSFORMERS\n// ==================\n//\n// Monads do not compose directly, we need to use Monad Transformers\n\n(**\n\u0060\u0060\u0060f#\nlet fn : ResultT\u003CReader\u003Cint,Result\u003C_,string\u003E\u003E\u003E = \n    monad {\n       let! x1 = lift ask\n       let! x2 = \n           if x1 \u003E 0 then result 1\n           else ResultT (result (Error \u0022Negative value\u0022))\n       return x1 \u002B x2\n    }\n\nlet x = (fn |\u003E ResultT.run |\u003E Reader.run) 10\n// Result\u003Cint,string\u003E = Ok 11\nlet y = (fn |\u003E ResultT.run |\u003E Reader.run) -1\n// Result\u003Cint,string\u003E = Error \u0022Negative value\u0022\n\u0060\u0060\u0060\n*)\n\n\n// The following example comes from Haskell\n// async is used instead of IO\n\nopen System\n\n// First let\u0027s define some functions we\u0027ll use later\nlet getLine    = async { return Console.ReadLine () }\nlet putStrLn x = async { printfn \u0022%s\u0022 x }\nlet isValid s =\n    String.length s \u003E= 8\n        \u0026\u0026 String.exists Char.IsLetter s\n        \u0026\u0026 String.exists Char.IsNumber s\n        \u0026\u0026 String.exists Char.IsPunctuation s\n\nlet decodeError = function\n    | -1 -\u003E \u0022Password not valid\u0022\n    | _  -\u003E \u0022Unknown\u0022\n\n\n// Now the following functions compose the Error monad with the Async one.\n\nlet getValidPassword : ResultT\u003C_\u003E =\n    monad {\n        let! s = liftAsync getLine\n        if isValid s then return s\n        else return! throw -1}\n    \u003C/catch/\u003E\n        (fun s -\u003E throw (\u0022The error was: \u0022 \u002B decodeError s))\n\nlet askPassword = monad {\n    do! lift \u003C| putStrLn \u0022Insert your new password:\u0022\n    let! value = getValidPassword\n    //do! lift \u003C| putStrLn \u0022Storing in database...\u0022\n    return value}\n\n//try -\u003E Async.RunSynchronously (ResultT.run askPassword)\n\n\n// After getting used to monadic CEs it\u0027s natural\n// to feel the need to combine monads\n// (from https://stackoverflow.com/a/37900264 )\n\nmodule CombineWriterWithResult =\n    \n    let divide5By = function\n        | 0.0 -\u003E Error \u0022Divide by zero\u0022\n        | x   -\u003E Ok (5.0 / x)\n\n    let eitherConv logSuccessF logFailF f v =\n        ResultT \u003C|\n            match f v with\n            | Ok a -\u003E Writer(Ok a, [\u0022Success: \u0022 \u002B logSuccessF a])\n            | Error b -\u003E Writer(Error b, [\u0022ERROR: \u0022   \u002B logFailF b])\n\n    let ew = monad {\n        let! x = eitherConv (sprintf \u0022%f\u0022) (sprintf \u0022%s\u0022) divide5By 6.0\n        let! y = eitherConv (sprintf \u0022%f\u0022) (sprintf \u0022%s\u0022) divide5By 3.0\n        let! z = eitherConv (sprintf \u0022%f\u0022) (sprintf \u0022%s\u0022) divide5By 0.0\n        return (x, y, z) }\n\n    let (_, log) = ew |\u003E ResultT.run |\u003E Writer.run\n\n\n// You can also stack monad transformers.\n\n// A monad transformer and a monad is itself a monad, so you can pass that into another monad transformer.\n// For example, below we are stacking them like:\n// type Example = ReaderT\u003CDateTime, ResultT\u003CWriter\u003Cstring list, Result\u003Cstring * string * string, string\u003E\u003E\u003E\u003E)\n\n// Catch and throw is generic over all monad transformers in F#\u002B so catch works in this example\n// because there is a Result in the stack. We use it here to consolidate Result\u0027s \u0027TError.\n\nmodule CombineReaderWithWriterWithResult =\n\n    let divide5By : float -\u003E Result\u003Cfloat, string\u003E = function\n        | 0.0 -\u003E Error \u0022Divide by zero\u0022\n        | x   -\u003E Ok (5.0 / x)\n\n    let otherDivide5By : float -\u003E Result\u003Cfloat, unit\u003E  = function\n        | 0.0 -\u003E Error ()\n        | x   -\u003E Ok (5.0 / x)\n\n    let eitherConv f v =\n        ReaderT \u003C| fun (now : System.DateTime) -\u003E\n        ResultT \u003C|\n            match f v with\n            | Ok a    -\u003E Writer(Ok a,    [sprintf \u0022Success at %s: %A\u0022 (now.ToString \u0022o\u0022) a])\n            | Error b -\u003E Writer(Error b, [sprintf \u0022ERROR at %s: %A\u0022   (now.ToString \u0022o\u0022) b])\n\n    let divide = monad {\n        let! w = eitherConv divide5By       6.0\n        let! x = eitherConv divide5By       3.0\n        let! y = eitherConv divide5By       0.0\n        let! z = eitherConv otherDivide5By  0.0 \u003C/catch/\u003E (throw \u003C\u003C (fun _ -\u003E \u0022Unknown error\u0022))\n\n        return (w, x, y, z) }\n\n    let run expr = ReaderT.run expr \u003E\u003E ResultT.run \u003E\u003E Writer.run\n\n    let (_, log) = run divide DateTime.UtcNow\n\n\n// Many popular F# libraries are in fact an instantiation of a specific monad combination.\n// The following example demonstrate how to code a mini-Suave lib in a few lines\n\nmodule Suave =\n    // setup something that reminds us of what Suave can work with\n    // this is an overly simplified model of Suave in order to show how OptionT can be used \n    // in conjunction with generic Kleisli composition (fish) operator\n    type WebPart\u003C\u0027a\u003E = \u0027a -\u003E OptionT\u003CAsync\u003C\u0027a option\u003E\u003E\n    let inline succeed x = async.Return (Some x)\n\n    module WebPart =\n        /// Comment from \u003Ca href=\u0022https://github.com/SuaveIO/suave/blob/v2.4.3/src/Suave/WebPart.fsi#L39-L42\u0022\u003EWebPart.fsi\u003C/a\u003E\n        /// Entry-point for composing the applicative routes of the http application,\n        /// by iterating the options, applying the context, arg, to the predicate\n        /// from the list of options, until there\u0027s a match/a Some(x) which can be\n        /// run.\n        let choose (options: WebPart\u003C\u0027a\u003E list) = fun x -\u003E choice (List.map ((|\u003E) x) options)\n\n    module Http =\n        type HttpResponse = { status: int; content: string }\n        type HttpRequest  = { url: Uri; \u0060\u0060method\u0060\u0060: string }\n        type HttpContext  = { request: HttpRequest; response: HttpResponse }\n\n    module Successful =\n        open Http\n        let private withStatusCode statusCode s =\n            OptionT \u003C\u003C fun ctx -\u003E { ctx with response = { ctx.response with status = statusCode; content = s }} |\u003E succeed\n        let OK s = withStatusCode 200 s\n        let BAD_REQUEST s = withStatusCode 400 s\n\n    module Filters =\n        open Http\n        let \u0060\u0060method\u0060\u0060 (m: string) =\n            OptionT \u003C\u003C fun (x: HttpContext) -\u003E async.Return (if (m = x.request.\u0060\u0060method\u0060\u0060) then Some x else None)\n        let GET  (x : HttpContext) = \u0060\u0060method\u0060\u0060 \u0022GET\u0022 x\n        let POST (x : HttpContext) = \u0060\u0060method\u0060\u0060 \u0022POST\u0022 x\n  \n        let path s =\n            OptionT \u003C\u003C fun (x: HttpContext) -\u003E async.Return (if (s = x.request.url.AbsolutePath) then Some x else None)\n\n    // Stub implementations: here you can plug Fleece or another similar Json library\n    let toJson o : string  = failwith \u0022Not implemented\u0022\n    let ofJson (s: string) = failwith \u0022Not implemented\u0022\n\n    module Request =\n        let tryGet _s (_r: Http.HttpRequest) = Ok \u0022FORM VALUE\u0022\n\n    let authenticated (f: Http.HttpContext -\u003E int -\u003E OptionT\u003CAsync\u003C\u0027a option\u003E\u003E) =\n        // we assume that authenticated executes f only if auth, otherwise returns 401\n        // we fake it as:\n        fun (ctx: Http.HttpContext) -\u003E f ctx -1\n\n    // Usage:\n    open Successful\n    open Filters\n    type Note = { id: int; text: string }\n    type NoteList = { notes: Note list; offset: int; chunk: int; total: int }\n    type IDb =\n        abstract member getUserNotes: int -\u003E Async\u003CNoteList\u003E\n        abstract member addUserNote: int -\u003E string -\u003E Async\u003CNote\u003E\n    type OverviewViewModel = { myNotes: Note list }\n    let app (db: IDb) =\n        let overview =\n            GET \u003E=\u003E (authenticated \u003C| fun ctx userId -\u003E\n                monad {\n                  let! res = lift (db.getUserNotes userId)\n                  let ovm = toJson { myNotes = res.notes }\n                  return! OK ovm ctx\n                })\n        let register =\n            POST \u003E=\u003E (authenticated \u003C| fun ctx userId -\u003E\n                monad {\n                  match ctx.request |\u003E Request.tryGet \u0022text\u0022 with \n                  | Ok text -\u003E\n                      let! newNote = lift (db.addUserNote userId text)\n                      let rvm = toJson newNote\n                      return! OK rvm ctx\n                  | Error msg -\u003E \n                      return! BAD_REQUEST msg ctx\n                })\n        WebPart.choose [ path \u0022/\u0022 \u003E=\u003E (OK \u0022/\u0022)\n                         path \u0022/note\u0022 \u003E=\u003E register\n                         path \u0022/notes\u0022 \u003E=\u003E overview ]"},{"uri":"/FSharpPlus/computation-expressions.html","title":"Computations Expressions\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\nopen FSharpPlus\nopen FSharpPlus.Data\n\n(**\nComputations Expressions\n========================\n\nThis library allows to use some common computation expressions without writing any boiler plate code.\n\nFor applicatives there is single computation expression: \u0060\u0060applicative { .. }\u0060\u0060. Additionally \u0060\u0060applicative2 { .. }\u0060\u0060 and \u0060\u0060applicative3 { .. }\u0060\u0060 exists for composed (aka layered) applicatives.\n\nFor monadic code there is a single computation expression: \u0060\u0060monad { .. }\u0060\u0060 but it comes in 4 flavours:\n\n - Delayed or strict\n\n   Delayed computations require that the type implements a TryWith, TryFinally and optionally a Delay method.\n   F# comes with async and seq computation expressions, both are delayed.\n\n - It can have embedded side-effects or act as a monadplus\n\n   A monadplus can return (or yield) many times, so for example all expressions in a loop can be returned, whereas in the other model those expressions are of type unit, since a side effect is expected.\n\n   Async workflows is an example of a side-effect computation expression and seq expressions are an example of monadplus.\n\n   Side effect workflows don\u0027t have any additional requirement over the type (apart from the monad operations), but monadplus requires the additional [get_Empty and (\u003C|\u003E)](abstraction-alternative.html) methods.\n\n  The generic computation expression \u0060\u0060monad\u0060\u0060 is a side-effect one, but it can be turned into a monadplus by accessing the \u0060\u0060.plus\u0060\u0060 property. \n  Note that \u0060\u0060monad.fx\u0060\u0060 is an alias for \u0060\u0060monad\u0060\u0060: fx is used as an abbreviation for side-effects.\n\n  These computations are lazy by default, but they can be made strict by adding \u0060\u0060.strict\u0060\u0060 or using a \u0060\u0060\u0027\u0060\u0060, ie \u0060\u0060monad.plus\u0027\u0060\u0060.\n\nIn other words:\n\n - \u0060\u0060monad.fx\u0060\u0060 or simply \u0060\u0060monad\u0060\u0060: Lazy monadic builder. Use when you want to use side-effects instead of the additive behavior of monad plus.\n - \u0060\u0060monad.fx.strict\u0060\u0060 (or \u0060\u0060monad.fx\u0027\u0060\u0060 or simply \u0060\u0060monad.strict\u0060\u0060 or \u0060\u0060monad\u0027\u0060\u0060) is the strict version of \u0060\u0060monad\u0060\u0060.\n - \u0060\u0060monad.plus\u0060\u0060: Lazy additive monadic builder. Use when you expect one or more results.\n - \u0060\u0060monad.plus\u0027\u0060\u0060 is the strict version of \u0060\u0060monad.plus\u0060\u0060\n\nNote that a type is either lazy or strict, but it could act as fx or plus at the same time (see below some examples). This means that we need to pay attention when using a CE over a type, if the type is lazy but with use a strict monad, we\u0027ll get strict semantics which probably would make no sense, but if we do the opposite we might run into runtime errors, fortunately a compile-time warning (or error) will prevent us.\n\nA simple way to find out if a type is strict or lazy is to execute this in fsi: \u0060let _ : MyType\u003C\u0027t\u003E = monad { printfn \u0022I\u0027m strict\u0022 }\u0060\n\nFor layered monads (monad transformers) the general rule is: the monad is strict unless at least one of its constituent types is lazy, in that case the whole monad becomes lazy.\n\n*)\n\nlet _ : OptionT\u003Clist\u003Cunit option\u003E\u003E = monad { printfn \u0022I\u0027m strict\u0022 }\n// will print I\u0027m strict, because OptionT and list are strict\n\nlet _ : OptionT\u003Cseq\u003Cunit option\u003E\u003E = monad { printfn \u0022I\u0027m strict\u0022 }\n// won\u0027t print anything, because seq is lazy\n\n(**\n\n\nExamples\n========\n\nYou may run this script step-by-step.\n\n\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\nopen FSharpPlus\n\nlet lazyValue = monad {\n    let! a = lazy (printfn \u0022I\u0027m lazy\u0022; 2)\n    let! b = lazy (printfn \u0022I\u0027m lazy too\u0022; 10)\n    return a \u002B b}\n\n// val lazyValue : System.Lazy\u003Cint\u003E = Value is not created.\n\nlet res12 = lazyValue.Value\n\n\nlet maybeWithSideFx = monad\u0027 { \n    let! a = Some 3\n    let b = ref 0\n    while !b \u003C 10 do \n        let! n = Some ()\n        incr b\n    if a = 3 then printfn \u0022got 3\u0022\n    else printfn \u0022got something else (will never print this)\u0022\n    return a }\n\n// val maybeWithSideFx : int option = Some 3\n\n\n\nlet lst = [None; None; Some 2; Some 4; Some 10; None]\n\nlet maybeManyTimes = monad.plus\u0027 {\n    let defaultValue = 42\n    let mutable i = 0\n    return! None\n    while i \u003C 5 do\n        printfn \u0022looping %i\u0022 i\n        i \u003C- i \u002B 1\n        return! lst.[i]\n    printfn \u0022halfway\u0022\n    return! None\n    printfn \u0022near the end\u0022\n    return defaultValue }\n\n// val maybeManyTimes : int option = Some 2\n\n\nlet (asnNumber: Async\u003C_\u003E) = monad.fx {\n    let mutable m = ResizeArray ()\n    try\n        for i = 1 to 10 do\n            m.Add i\n        return m.[-1]\n    with e -\u003E\n        return -3 }\n\n\nlet (lstNumber: list\u003C_\u003E) = monad.plus\u0027 {\n    try\n        for i = 1 to 10 do\n            return i\n    with e -\u003E\n        return -3 }\n\n\n(*\nFor more information about computation expressions you can read the paper : The F# Computation Expression Zoo\nhttp://tomasp.net/academic/papers/computation-zoo/computation-zoo.pdf\n*)"},{"uri":"/FSharpPlus/tutorial.html","title":"Introducing FSharpPlus\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n#nowarn \u00220058\u0022 // We need to cheat a bit with indentation here.\n\n(**\nIntroducing FSharpPlus\n======================\n\n - Download binaries from [Nuget](https://www.nuget.org/packages/FSharpPlus/), use the latest CI version.\n\n - Open an F# script file or the F# interactive, reference the library and open the namespace\n\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\nopen FSharpPlus\n\n(**\n Ignore warnings about F# metadata if any.\n\n\nNow we\u0027ll start with a quick overview of the features presented in F#\u002B.\n\n### Generic functions \n\nThey are automatically available when opening the FSharpPlus namespace\n\nhere\u0027s an example with \u003Ccode\u003Emap\u003C/code\u003E ([fmap](https://wiki.haskell.org/Functor) for Haskellers, [Select](http://www.dotnetperls.com/select) for C-sharpers):\n\n*)\n\nmap string [|2;3;4;5|]\n// val it : string [] = [|\u00222\u0022; \u00223\u0022; \u00224\u0022; \u00225\u0022|]\n\nmap ((\u002B) 9) (Some 3)\n// val it : int option = Some 12\n\nopen FSharpPlus.Data\n\nmap string (NonEmptyList.create 2 [3;4;5])\n// val it : NonEmptyList\u003Cstring\u003E = {Head = \u00222\u0022; Tail = [\u00223\u0022; \u00224\u0022; \u00225\u0022];}\n\n(**\nThey\u0027re also available for your own types as long as they contain the appropriated method with the expected signature\n*)\n\n\ntype Tree\u003C\u0027t\u003E =\n    | Tree of \u0027t * Tree\u003C\u0027t\u003E * Tree\u003C\u0027t\u003E\n    | Leaf of \u0027t\n    static member Map (x:Tree\u003C\u0027a\u003E, f) = \n        let rec loop f = function\n            | Leaf x -\u003E Leaf (f x)\n            | Tree (x, t1, t2) -\u003E Tree (f x, loop f t1, loop f t2)\n        loop f x\n\nmap ((*) 10) (Tree(6, Tree(2, Leaf 1, Leaf 3), Leaf 9))\n// val it : Tree\u003Cint\u003E = Tree (60,Tree (20,Leaf 10,Leaf 30),Leaf 90)\n\n(**\nGeneric functions may be seen as an exotic thing in F# that only saves a few key strokes (\u003Ccode\u003Emap\u003C/code\u003E instead of \u003Ccode\u003EList.map\u003C/code\u003E or \u003Ccode\u003EArray.map\u003C/code\u003E) still they allow you to reach a higher abstraction level, using ad-hoc polymorphism.\n\nBut more interesting is the use of operators. You can\u0027t prefix them with the module they belong to, well you can but then it\u0027s no longer an operator. As an example many F# libraries define the bind operator \u003Ccode\u003E(\u003E\u003E=)\u003C/code\u003E but it\u0027s not generic so if you use two different types which are both monads you will need to prefix it e.g. \u003Ccode\u003EState.(\u003E\u003E=)\u003C/code\u003E and \u003Ccode\u003EReader.(\u003E\u003E=)\u003C/code\u003E which defeats the purpose of having an operator.\n\nHere you have a ready-to-use generic bind operator: \u0060\u0060\u003E\u003E=\u0060\u0060\n*)\n\nlet x = [\u0022hello\u0022;\u0022 \u0022;\u0022world\u0022] \u003E\u003E= (fun x -\u003E Seq.toList x)\n// val x : char list = [\u0027h\u0027; \u0027e\u0027; \u0027l\u0027; \u0027l\u0027; \u0027o\u0027; \u0027 \u0027; \u0027w\u0027; \u0027o\u0027; \u0027r\u0027; \u0027l\u0027; \u0027d\u0027]\n\n\nlet tryParseInt : string -\u003E int option = tryParse\nlet tryDivide x n = if n = 0 then None else Some (x / n)\n\nlet y = Some \u002220\u0022 \u003E\u003E= tryParseInt \u003E\u003E= tryDivide 100\n// val y : int option = Some 5\n\n(**\nYou have also the Kleisli composition (fish) operator:  \u0060\u0060\u003E=\u003E\u0060\u0060\n\nWhich is becoming popular in F# after the [Railway Oriented Programming](https://www.google.ch/#q=railway\u002Boriented\u002Bprogramming) tutorial series\n*)\n\nlet parseAndDivide100By = tryParseInt \u003E=\u003E tryDivide 100\n\nlet parsedAndDivide100By20 = parseAndDivide100By \u002220\u0022   // Some 5\nlet parsedAndDivide100By0\u0027 = parseAndDivide100By \u0022zero\u0022 // None\nlet parsedAndDivide100By0  = parseAndDivide100By \u00220\u0022    // None\n\nlet parseElement n = List.tryItem n \u003E=\u003E tryParseInt\nlet parsedElement  = parseElement 2 [\u00220\u0022; \u00221\u0022;\u00222\u0022]\n\n(**\nBut don\u0027t forget the above used operators are generic, so we can change the type of our functions and we get a different functionality for free:\n*)\n\n(*** hide ***)\nmodule E2 =\n\nlet tryParseInt x : Choice\u003Cint, string\u003E = \n    match tryParse x with \n    | Some x -\u003E Choice1Of2 x\n    | None   -\u003E Choice2Of2 (\u0022Failed to parse \u0022 \u002B x)\n        \n\nlet tryDivide x n = \n    if n = 0 then Choice2Of2 \u0022Can\u0027t divide by zero\u0022\n    else Choice1Of2 (x / n)\n\n(**\nThe test code remains unchanged, but we get a more interesting functionality\n*)\n\nlet parseAndDivide100By = tryParseInt \u003E=\u003E tryDivide 100\n\nlet parsedAndDivide100By20 = parseAndDivide100By \u002220\u0022   // Choice1Of2 5\nlet parsedAndDivide100By0\u0027 = parseAndDivide100By \u0022zero\u0022 // Choice2Of2 \u0022Failed to parse zero\u0022\nlet parsedAndDivide100By0  = parseAndDivide100By \u00220\u0022    // Choice2Of2 \u0022Can\u0027t divide by zero\u0022\n\n\n(**\n\nAlso when working with combinators, the generic applicative functor (space invaders) operator is very handy: \u0060\u0060\u003C*\u003E\u0060\u0060\n*)\n\nlet sumAllOptions = Some (\u002B) \u003C*\u003E Some 2 \u003C*\u003E Some 10     // val sumAllOptions : int option = Some 12\n\nlet sumAllElemets = [(\u002B)] \u003C*\u003E [10; 100] \u003C*\u003E [1; 2; 3]   // int list = [11; 12; 13; 101; 102; 103]\n\n(**\n\nFor more details and features, see [generic operators and functions](generic-doc.html)\n\nHere are all [generic operators and functions](reference\\fsharpplus-operators.html)\n\nAnd [here\u0027s a short explanation](applicative-functors.html) of Functor, Applicative and Monad abstractions with code samples.\n\n\n\n### Lens\n\n\n\nfrom https://github.com/ekmett/lens/wiki/Examples\n\n\nFirst, open F#\u002B Lens\n*)\n\nopen FSharpPlus.Lens\n\n(** Now, you can read from lenses (\u0060\u0060_2\u0060\u0060 is a lens for the second component of a tuple) *)\n\nlet r1 = (\u0022hello\u0022,\u0022world\u0022)^._2\n// val it : string = \u0022world\u0022\n\n(** and you can write to lenses. *)\nlet r2 = setl _2 42 (\u0022hello\u0022,\u0022world\u0022)\n// val it : string * int = (\u0022hello\u0022, 42)\n\n(**  Composing lenses for reading (or writing) goes in the order an imperative programmer would expect, and just uses \u0060\u0060(\u003C\u003C)\u0060\u0060. *)\nlet r3 = (\u0022hello\u0022,(\u0022world\u0022,\u0022!!!\u0022))^.(_2 \u003C\u003C _1)\n// val it : string = \u0022world\u0022\n\nlet r4 = setl (_2 \u003C\u003C _1) 42 (\u0022hello\u0022,(\u0022world\u0022,\u0022!!!\u0022))\n// val it : string * (int * string) = (\u0022hello\u0022, (42, \u0022!!!\u0022))\n\n(**  You can make a Getter out of a pure function with \u0060\u0060to\u0027\u0060\u0060. *)\nlet r5 = \u0022hello\u0022^.to\u0027 length\n// val it : int = 5\n\n(**  You can easily compose a Getter with a Lens just using \u0060\u0060(\u003C\u003C)\u0060\u0060. No explicit coercion is necessary. *)\nlet r6 = (\u0022hello\u0022,(\u0022world\u0022,\u0022!!!\u0022))^. (_2 \u003C\u003C _2 \u003C\u003C to\u0027 length)\n// val it : int = 3\n\n(**  As we saw above, you can write to lenses and these writes can change the type of the container. \u0060\u0060(.-\u003E)\u0060\u0060 is an infix alias for \u0060\u0060set\u0060\u0060. *)\nlet r7 = _1 .-\u003E \u0022hello\u0022 \u003C| ((),\u0022world\u0022)\n// val it : string * string = (\u0022hello\u0022, \u0022world\u0022)\n\n(**  It can be used in conjunction with \u0060\u0060(|\u003E)\u0060\u0060 for familiar von Neumann style assignment syntax: *)\nlet r8 = ((), \u0022world\u0022) |\u003E _1 .-\u003E \u0022hello\u0022\n// val it : string * string = (\u0022hello\u0022, \u0022world\u0022)\n\n(**  Conversely view, can be used as an prefix alias for \u0060\u0060(^.)\u0060\u0060. *)\nlet r9 = view _2 (10,20)\n// val it : int = 20\n\n(**\n\nFor more details:\n\nHere\u0027s a full tour of [lens and all other optics](lens.html)\n\nHave a look at all [lens functions](reference\\fsharpplus-lens.html)\n*)"},{"uri":"/FSharpPlus/type-ziplist.html","title":"ZipList\u003C\u0027T\u003E\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nZipList\u003C\u0027T\u003E\n===========\n\nThis is a wrapper over seq\u003C\u0027T\u003E which changes its applicative semantic to point-wise processing.\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\nopen FSharpPlus\nopen FSharpPlus.Data\n\nlet seq1 = seq { 1..100000}\nlet seq2 = seq {10..100000}\n\nlet seq1_plus_seq2  = (\u002B) \u003C!\u003E ZipList seq1 \u003C*\u003E ZipList seq2\n\nopen FSharpPlus.Math.Applicative\n\nlet seq1_plus_seq2\u0027 = ZipList seq1 .\u002B. ZipList seq2\nlet arrCombined     = 10 *. ZipList seq1 .\u002B. ZipList seq2 .- 5\nlet asMonoid        = result \u0022Hello \u0022 \u003C/plus/\u003E ZipList [\u0022City\u0022; \u0022World\u0022; \u0022Sun\u0022]\n\n// try ZipList.run {the results}"},{"uri":"/FSharpPlus/type-dual.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/type-vector.html","title":"Vector\u003C\u0027NumType,\u0027Dimension\u003E\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n#r @\u0022../../src/FSharpPlus.TypeLevel/bin/Release/netstandard2.0/FSharpPlus.TypeLevel.dll\u0022\n\n(**\nVector\u003C\u0027NumType,\u0027Dimension\u003E\n===========================\n\nThis is a fixed size vector of a (typically) numeric type.\n\nRelated Tyes\n------------\n\n - [Matrix](type-matrix.html): Similar but for matrices\n \n\n\n\nAbstractions\n------------\n\n -  [Semigroup](abstraction-semigroup.html)\n -  [Monoid](abstraction-monoid.html)\n -  [Functor](abstraction-functor.html)\n -  [ZipFunctor](abstraction-misc.html)\n -  [Applicative](abstraction-applicative.html)\n -  [Foldable](abstraction-foldable.html)\n -  [Reducible](abstraction-misc.html)\n\n\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n#r @\u0022nuget: FSharpPlus.TypeLevel\u0022\n\u0060\u0060\u0060\n*)\nopen FSharpPlus\nopen FSharpPlus.Data\n\n\nlet vector3d_1 = vector (1, 2, 3)\nlet vector3d_2 = vector (10, 20, 30)\n\n\n// Add two vectors\n\nlet vector3d_sum = vector3d_1 \u002B vector3d_2\n\n\n// Add a scalar\n\nlet vector3d_3 = vector (1, 2, 3) \u002B result 5\n\n\n// Another way\n\nopen FSharpPlus.Math.Generic\n\nlet vector3d_4 = vector (1, 2, 3) \u002B 5G"},{"uri":"/FSharpPlus/type-free.html","title":"Free\u003C\u0027Functor\u003C\u0027T\u003E, \u0027T\u0026gt;\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nFree\u003C\u0027Functor\u003C\u0027T\u003E, \u0027T\u003E\n======================\n\nThis type is an implementation of the [Free Monad](https://www.google.com/search?q=free\u002Bmonad) which is generic to any [Functor](abstraction-functor.html).\n\nThe Free Monad is used typically to describe a pure program at high level and separately write different interpreters for it.\n\nRelated Types\n-------------\n\n - [Coproduct](type-coproduct.html): A [Functor](abstraction-functor.html) used in conjunction with the Free Monad to combine different instruction sets.\n\n\n\n\nExamples\n--------\n\nFree monad-interpreter in F# from [Mark Seemann\u0027s blog](https://blog.ploeh.dk/2017/07/17/a-pure-command-line-wizard) but encoded with Free.\n\n*)\n\n\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen System\nopen FSharpPlus\nopen FSharpPlus.Data\n\n\ntype CommandLineInstruction\u003C\u0027t\u003E =\n    | ReadLine  of (string -\u003E \u0027t)\n    | WriteLine of  string  * \u0027t\nwith static member Map (x, f) =\n        match x with\n        | ReadLine   g     -\u003E ReadLine  (f \u003C\u003C g)\n        | WriteLine (s, g) -\u003E WriteLine (s, f g)\n\nlet readLine    = Free.liftF (ReadLine id)\nlet writeLine s = Free.liftF (WriteLine (s, ()))\n\n\nlet rec interpretCommandLine = Free.run \u003E\u003E function\n    | Pure x -\u003E x\n    | Roll (ReadLine      next)  -\u003E Console.ReadLine () |\u003E next |\u003E interpretCommandLine\n    | Roll (WriteLine (s, next)) -\u003E\n        Console.WriteLine s\n        next |\u003E interpretCommandLine\n\nlet rec readQuantity = monad {\n    do! writeLine \u0022Please enter number of diners:\u0022\n    let! l = readLine\n    match tryParse l with\n    | Some dinerCount -\u003E return dinerCount\n    | None -\u003E\n        do! writeLine \u0022Not an integer.\u0022\n        return! readQuantity }\n\nlet rec readDate = monad {\n    do! writeLine \u0022Please enter your desired date:\u0022\n    let! l = readLine\n    match DateTimeOffset.TryParse l with\n    | true, dt -\u003E return dt\n    | _ -\u003E\n        do! writeLine \u0022Not a date.\u0022\n        return! readDate }\n\nlet readName = monad {\n    do! writeLine \u0022Please enter your name:\u0022\n    return! readLine }\n \nlet readEmail = monad {\n    do! writeLine \u0022Please enter your email address:\u0022\n    return! readLine }\n\n\ntype Reservation = {\n    Date : DateTimeOffset\n    Name : string\n    Email : string\n    Quantity : int }\n    with static member Create (Quantity, Date, Name, Email) = { Date = Date; Name = Name; Email = Email; Quantity = Quantity }\n\nlet readReservationRequest =\n    curryN Reservation.Create\n    \u003C!\u003E readQuantity\n    \u003C*\u003E readDate\n    \u003C*\u003E readName\n    \u003C*\u003E readEmail\n\n\n\nlet mainFunc () =\n    readReservationRequest\n    \u003E\u003E= (writeLine \u003C\u003C (sprintf \u0022%A\u0022))\n    |\u003E interpretCommandLine\n    0\n\n\n(**\nMore reading\n------------\n\n - Highly recommended Matt Thornton\u0027s blog [Grokking Free monads](https://dev.to/choc13/grokking-free-monads-9jd) and [Interpreting Free Monads](https://dev.to/choc13/interpreting-free-monads-3l3e).\n   It contains examples using F#\u002B and an explanation from scratch.\n\n - Mark Seemann\u0027s blog has an [article series](https://blog.ploeh.dk/2017/06/27/pure-times/) which ends \n   up describing Free Monads although he doesn\u0027t use F#\u002B and therefore either repeats boilerplate code or switches to Haskell.\n   Anyways some code from those series (like the above fragment) can be found in [our test suite for Free](https://github.com/fsprojects/FSharpPlus/blob/master/tests/FSharpPlus.Tests/Free.fs) simplified using Free and Coproduct types.\n\n - Scott Wlaschin\u0027s [13 ways of looking at a turtle](https://fsharpforfunandprofit.com/posts/13-ways-of-looking-at-a-turtle) is also a series which ends up defining a Free Monad, without using F#\u002B but with boilerplate code instead.\n\n*)"},{"uri":"/FSharpPlus/parsing.html","title":"Parsing\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\nopen System\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\nopen FSharpPlus\n(**\n# Parsing\n\nF#\u002B provides several helper methods in order to simplify building parsers and parsing like tasks. \n*)\n\n(**\n## Parse\n\nParse allows you to use \u0060parse\u0060 generic method for standard types and types that implement a static Parse method with the correct signature.\n\n\n### Minimal definition\n\n*)\n\n(**\n\u0060\u0060\u0060f#\nstatic member Parse (x:\u0027r) :\u0027T\n\u0060\u0060\u0060\nor\n\n\u0060\u0060\u0060f#\nstatic member Parse (x:\u0027r, c:CultureInfo) :\u0027T\n\u0060\u0060\u0060\n\n*)\n\n(**\n## TryParse\n\nTryParse allows you to use \u0060tryParse\u0060 generic method for standard types and types that implement a static TryParse method with the correct signature.\n\n### Minimal definition\n\nIn order to use \u0060tryParse\u0060 together with a type the type needs to implement a TryParse like static method.\n\n*)\n\n(**\nYou can use F# style TryParse:\n\u0060\u0060\u0060f#\nstatic member TryParse(value:\u0027r) : \u0027T option\n\u0060\u0060\u0060\nor C# style TryParse:\n\u0060\u0060\u0060f#\nstatic member TryParse (x:\u0027r, [\u003COut\u003E] result: \u0027T byref) :bool\n\u0060\u0060\u0060\nexpressed in C# that would be:\n\u0060\u0060\u0060c#\npublic static bool TryParse (string x, out T result) \n\u0060\u0060\u0060\n\nA neat thing when you have types that implement the above definition is that it\u0027s simple to define active patterns:\n*)\n\nlet (|Port|_|) : _-\u003E UInt16 option = tryParse\nlet (|IPAddress|_|) :_-\u003ESystem.Net.IPAddress option = tryParse\n\n(**\n## sscanf, trySscanf and friends\n\nIn F# you have some nice utility functions for creating printf style string writer function. In F#\u002B we find the inverse: sscanf and trySscanf.\n\nFor instance if you want to parse based on known format of a url:\n*)\n\nlet route1 x = trySscanf \u0022/api/resource/%d\u0022 x\nlet parsed : int option = route1 \u0022/api/resource/1\u0022"},{"uri":"/FSharpPlus/type-endo.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/type-reader.html","title":"Reader\u003C\u0027R,\u0027T\u003E\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nReader\u003C\u0027R,\u0027T\u003E\n=============\n\nThe Reader monad is good for computations which read values from a shared environment.\n\nRelated Types\n------------\n\n - [State](type-state.html): Similar, but it allows you to modify the environment.\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\n(**\nOne usage of the Reader monad is an alternative to dependency injection or currying\nin order to pass around dependencies. The below code comes from [F# Online - Josef Star\u00FDchfojt\u016F - FSharpPlus - Advanced FP concepts in F#](https://www.youtube.com/watch?v=pxJCHJgG8ws). You can find the presenter on github as [@starychfojtu](https://github.com/starychfojtu).\n\nWhy would you want to do this style?\n\n- When you want to pass around a single environment instead of using dependency injection.\n\nWhy wouldn\u0027t you want to use this style?\n\n- The downside of this style is that it supposes that your environment is relatively immutable. If you have different lifetimes for different implementation classes dependency injection frameworks can be easier to use.\n\nNote:\n\n- The # in \u0060\u0060(env : #IUserRepository)\u0060\u0060 is a [flexible type annotation](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/flexible-types).\n*)\nopen System\nopen FSharpPlus\nopen FSharpPlus.Data\n\ntype IUserRepository =\n    abstract GetUser : email : string -\u003E string\n\ntype IShoppingListRepository =\n    abstract AddToCart : shoppingList : string list -\u003E string\n\nlet getUser email =\n    Reader(fun (env : #IUserRepository) -\u003E env.GetUser email)\n\nlet addToShoppingList shoppingListItems =\n    Reader(fun (env : #IShoppingListRepository) -\u003E env.AddToCart shoppingListItems)\n\nlet addShoppingListM email = monad {\n    let! user = getUser email\n    // \n    let shoppingListItems = [\u0022Apple\u0022; \u0022Pear\u0022;]\n    return! addToShoppingList shoppingListItems\n}\n\ntype MockDataEnv() = // This is how an environment could be constructed\n    interface IUserRepository with\n        member this.GetUser email =\n                \u0022Sandeep\u0022\n    interface IShoppingListRepository with\n            member this.AddToCart shoppingListItems =\n                sprintf \u0022Added the following items %A to the cart\u0022 shoppingListItems\n\nReader.run (addShoppingListM \u0022sandeep@test.com\u0022)  (MockDataEnv())\n\n(**\nSample from [The Reader monad on Haskell Wiki](https://wiki.haskell.org/All_About_Monads#The_Reader_monad)\n*)\nopen System\nopen FSharpPlus\nopen FSharpPlus.Data\n\n/// This the abstract syntax representation of a template\ntype Template =\n    /// Text\n    | T of string\n    /// Variable\n    | V of Template\n    /// Quote\n    | Q of Template\n    /// Include\n    | I of Template*(Definition list)\n    /// Compound\n    | C of Template list\nand Definition = | D of Template*Template\n\n/// Our environment consists of an association list of named templates and\n/// an association list of named variable values.\ntype Environment = {templates: Map\u003Cstring,Template\u003E\n                    variables: Map\u003Cstring,string\u003E}\n\n/// lookup a variable from the environment\nlet lookupVar (name:string) (env:Environment) : string option = tryItem name env.variables\n\n/// lookup a template from the environment\nlet lookupTemplate (name:string) (env:Environment) : Template option = tryItem name env.templates\n\n/// add a list of resolved definitions to the environment\nlet addDefs (defs:(string*string) list) env = { env with variables = plus (Map.ofList defs) env.variables}\n\n/// resolve a template into a string\nlet rec resolve : Template -\u003E Reader\u003CEnvironment,string\u003E  = function \n                       | T s -\u003E result s\n                       | V t -\u003E monad {\n                                   let! varName = resolve t\n                                   let! env = ask\n                                   let varValue = lookupVar varName env\n                                   return option id \u0022\u0022 varValue }\n                        | Q t -\u003E monad {\n                                   let! tmplName = resolve t\n                                   let! env = ask\n                                   let body = lookupTemplate tmplName env\n                                   return option string \u0022\u0022 body }\n                        | I (t,ds) -\u003E monad {\n                                    let! tmplName = resolve t\n                                    let! env = ask\n                                    let body = lookupTemplate tmplName env\n                                    match body with\n                                    | Some t\u0027 -\u003E\n                                                let! defs = List.traverse resolveDef ds\n                                                return! local (addDefs defs) (resolve t\u0027)\n                                    | None -\u003E return \u0022\u0022\n                                    }\n                        | C ts   -\u003E monad {\n                                      let! resolved = List.traverse resolve ts\n                                      return String.Concat\u003Cstring\u003E resolved\n                                    }\nand\n   /// resolve a Definition and produce a (name,value) pair\n   resolveDef: Definition -\u003E Reader\u003CEnvironment,string*string\u003E = \n                                      function \n                                      | D (t,d) -\u003E monad {\n                                        let! name = resolve t\n                                        let! value = resolve d\n                                        return (name,value) }\n"},{"uri":"/FSharpPlus/generic-doc.html","title":"Generic operators and functions\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\nopen FSharpPlus\n\n(**\nGeneric operators and functions\n===============================\n\nAfter reviewing [extension functions](extensions.html) it\u0027s natural to want to\nuse generic functions that can work across different types.\n\nF#\u002B implements generic functions that efficiently call out to specific\nimplementations. This handles existing .Net and F# types, and you can use them\non your own and third-party types by implementing expected method names\nand signatures.\n\nRead about the specific operators:\n\n * Docs on [Operators - Common Combinators](operators-common.html)\n * Other docs exist for each [abstraction](abstractions.html)\n * API Doc for [Generic functions and operators](reference/fsharpplus-operators.html)\n\nThey\u0027re particularly useful in that the specific function called will\ndepend on the input arguments and return type. However, this means you\nsometimes need to explicitly specify the type if this information is\nnot available (actually it\u0027s a good debug technique to temporarily add\nthe types explicitly when the compiler tells you that the types are wrong).\n\nFor example:\n*)\n\n// Convert the number 42 to bytes... \n// ... here the type is known (42 is an int, the return value is byte[])\nlet a = 42 |\u003E toBytes;;  \n//val a : byte [] = [|42uy; 0uy; 0uy; 0uy|]\n\n// However, this can\u0027t compile since the return type is not inferrable\n// let b = [|42uy; 0uy; 0uy; 0uy|] |\u003E ofBytes;;  \n\n// The error will be something like:\n// \n//  let b = [|42uy; 0uy; 0uy; 0uy|] |\u003E ofBytes;;\n//  -----------------------------------^^^^^^^\n//\n// error FS0071: Type constraint mismatch when applying the default type \u0027obj\u0027\n// for a type inference variable. No overloads match for method \u0027OfBytes\u0027.\n// The available overloads are shown below. Consider adding further type constraints\n\n// [followed by many possible implementations...]\n\n// So, in this case, we have to give the return type:\nlet b :int = [|42uy; 0uy; 0uy; 0uy|] |\u003E ofBytes;;\n// val b : int = 42\n\n// ...or, the more usual case, you use in context where type can be inferred,\n// like this example:\n1 \u002B ([|42uy; 0uy; 0uy; 0uy|] |\u003E ofBytes);;\n//val it : int = 43\n\n(**\nHow do generic functions work?\n==============================\n\nF# does not support overloaded functions, but it does support overloaded\nmethods on types (classes) - including static methods. F#\u002B takes\nadvantage of this by definining generic functions that call out to\nan internal class (referred to as an \u0022Invokable\u0022) where various overloaded \nstatic methods are defined.\n\nAn Invokable is written such that the most specific, and hence, optimised\noverload is resolved for existing .Net and F# types, and that a more general\nimplementation is used otherwise.\n\nWhat does this all mean?\n\nIt means care is taken to use the most optimised implementation, and you can\nimplement your own instances of generic functions if you implement the required\nmethods.\n\nExamples\n========\n\nHere are some examples of the generic \u0060\u0060map\u0060\u0060 operation over existing .NET and F# types:\n\n*)\n\n\nmap string [|2;3;4;5|]\n// val it : string [] = [|\u00222\u0022; \u00223\u0022; \u00224\u0022; \u00225\u0022|]\n\nmap ((\u002B) 9) (Some 3)\n// val it : int option = Some 12\n\nlet res12 = map ((\u002B) 9) (async {return 3})\n// val it : Async\u003Cint\u003E = Microsoft.FSharp.Control.FSharpAsync\u00601[System.Int32]\nextract res12\n// val it : int = 12\n\n(**\nHere are some examples with types defined in this library:\n*)\n\nopen FSharpPlus.Data\n\nmap string (NonEmptyList.create 2 [3;4;5])\n// val it : NonEmptyList\u003Cstring\u003E = {Head = \u00222\u0022; Tail = [\u00223\u0022; \u00224\u0022; \u00225\u0022];}\n\nlet stateFul42 = map string (State (fun x -\u003E (42, x)))\nState.run stateFul42 \u0022state\u0022\n// val stateFul42 : State\u003Cstring,string\u003E = State \u003Cfun:map@12-9\u003E\n// val it : string * string = (\u002242\u0022, \u0022state\u0022)\n\n(**\nNow let\u0027s define our own type with its own map definition\n*)\n\ntype Tree\u003C\u0027t\u003E =\n    | Tree of \u0027t * Tree\u003C\u0027t\u003E * Tree\u003C\u0027t\u003E\n    | Leaf of \u0027t\n    static member Map (x:Tree\u003C\u0027a\u003E, f) = \n        let rec loop f = function\n            | Leaf x -\u003E Leaf (f x)\n            | Tree (x, t1, t2) -\u003E Tree (f x, loop f t1, loop f t2)\n        loop f x\n\nmap ((*) 10) (Tree(6, Tree(2, Leaf 1, Leaf 3), Leaf 9))\n// val it : Tree\u003Cint\u003E = Tree (60,Tree (20,Leaf 10,Leaf 30),Leaf 90)\n\n(**\n\nFor a type defined in an external library it will work when it contains a static member matching the expected name and signature.\n\nHere\u0027s an example of the generic function \u0060\u0060fromBigInt\u0060\u0060 targeting a type defined in the MathNet library\n*)\n#r \u0022../../packages/docs/MathNet.Numerics/lib/net40/MathNet.Numerics.dll\u0022\n#r \u0022../../packages/docs/MathNet.Numerics.FSharp/lib/net45/MathNet.Numerics.FSharp.dll\u0022\n\nlet x : MathNet.Numerics.BigRational = fromBigInt 10I"},{"uri":"/FSharpPlus/type-identity.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/abstraction-applicative.html","title":"Applicative\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nApplicative\n===========\nA functor with application, providing operations to embed pure expressions (\u0060\u0060return\u0060\u0060), and sequence computations and combine their results (\u0060\u0060\u003C*\u003E\u0060\u0060).\n___\nMinimal complete definition\n---------------------------\n * \u0060\u0060return x\u0060\u0060/\u0060\u0060result x\u0060\u0060 \n * \u0060\u0060(\u003C*\u003E) f x\u0060\u0060\n*)\n(**\n    static member Return (x:\u0027T) : \u0027Applicative\u003C\u0027T\u003E\n    static member (\u003C*\u003E) (f: \u0027Applicative\u003C\u0027T-\u003E\u0027U\u003E, x: \u0027Applicative\u003C\u0027T\u003E) : \u0027Applicative\u003C\u0027U\u003E\n*)\n(**\nNote: \u0060\u0060return\u0060\u0060 can\u0027t be used outside computation expressions, use \u0060\u0060result\u0060\u0060 instead.\n\n\nOther operations\n----------------\n\n* \u0060\u0060lift2\u0060\u0060\n*)\n(**\n   static member Lift2 (f: \u0027T1-\u003E\u0027T2-\u003E\u0027T, x1: \u0027Applicative\u003C\u0027T1\u003E, x2: \u0027Applicative\u003C\u0027T2\u003E) : \u0027Applicative\u003C\u0027T\u003E\n*)\n(**\n\n\nRules\n-----\n*)\n(**\n    result id \u003C*\u003E v = v\n    result (\u003C\u003C) \u003C*\u003E u \u003C*\u003E v \u003C*\u003E w = u \u003C*\u003E (v \u003C*\u003E w)\n    result f \u003C*\u003E result x = result (f x)\n    u \u003C*\u003E result y = result ((|\u003E) y) \u003C*\u003E u\n*)\n(**\nRelated Abstractions\n--------------------\n - [Functor](abstraction-functor.html): An applicative is a functor whose \u0060\u0060map\u0060\u0060 operation can be splitted in \u0060\u0060return\u0060\u0060 and \u0060\u0060(\u003C*\u003E)\u0060\u0060 operations,\n \n - [Monad](abstraction-monad.html) : Monads are functors with an additional \u0060\u0060Join\u0060\u0060 operation,\nConcrete implementations\n------------------------\nFrom F#\n \n -  \u0060\u0060seq\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060list\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060array\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060\u0027T [,]\u0060\u0060\n -  \u0060\u0060\u0027T [,,]\u0060\u0060\n -  \u0060\u0060\u0027T [,,,]\u0060\u0060\n -  \u0060\u0060option\u003C\u0027T\u003E\u0060\u0060 \n -  \u0060\u0060voption\u003C\u0027T\u003E\u0060\u0060 \n -  \u0060\u0060IObservable\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Lazy\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Async\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Result\u003C\u0027T,\u0027U\u003E\u0060\u0060 \n -  \u0060\u0060Choice\u003C\u0027T,\u0027U\u003E\u0060\u0060\n -  \u0060\u0060KeyValuePair\u003C\u0027Key,\u0027T\u003E\u0060\u0060\n -  \u0060\u0060\u0027Monoid * \u0027T\u0060\u0060\n -  \u0060\u0060\u0027ValueTuple\u003CMonoid, \u0027T\u003E\u0060\u0060\n -  \u0060\u0060Task\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060ValueTask\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060\u0027R-\u003E\u0027T\u0060\u0060\n -  \u0060\u0060Expr\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060ResizeArray\u003C\u0027T\u003E\u0060\u0060\n \nFrom F#\u002B\n\n -  [\u0060\u0060Identity\u003C\u0027T\u003E\u0060\u0060](type-identity.html)\n -  [\u0060\u0060Cont\u003C\u0027R,\u0027T\u003E\u0060\u0060](type-cont.html)\n -  [\u0060\u0060ContT\u003C\u0027R,\u0027T\u003E\u0060\u0060](type-contt.html)\n -  [\u0060\u0060Reader\u003C\u0027R,\u0027T\u003E\u0060\u0060](type-reader.html)\n -  [\u0060\u0060ReaderT\u003C\u0027R,\u0027Monad\u003C\u0027T\u003E\u003E\u0060\u0060](type-readert.html)\n -  [\u0060\u0060Writer\u003C\u0027Monoid,\u0027T\u003E\u0060\u0060](type-writer.html)\n -  [\u0060\u0060WriterT\u003C\u0027Monad\u003C\u0027T * \u0027Monoid\u003E\u003E\u0060\u0060](type-writert.html)\n -  [\u0060\u0060State\u003C\u0027S,\u0027T * \u0027S\u003E\u0060\u0060](type-state.html)\n -  [\u0060\u0060StateT\u003C\u0027S,\u0027Monad\u003C\u0027T * \u0027S\u003E\u003E\u0060\u0060](type-statet.html)\n -  [\u0060\u0060OptionT\u003C\u0027Monad\u003Coption\u003C\u0027T\u003E\u003E\u0060\u0060](type-optiont.html)\n -  [\u0060\u0060ValueOptionT\u003C\u0027Monad\u003Cvoption\u003C\u0027T\u003E\u003E\u0060\u0060](type-valueoptiont.html)\n -  [\u0060\u0060SeqT\u003C\u0027Monad\u003Cseq\u003C\u0027T\u003E\u003E\u0060\u0060](type-seqt.html)\n -  [\u0060\u0060ListT\u003C\u0027Monad\u003Clist\u003C\u0027T\u003E\u003E\u0060\u0060](type-listt.html)\n -  [\u0060\u0060ResultT\u003C\u0027Monad\u003CResult\u003C\u0027T,\u0027TError\u003E\u003E\u0060\u0060](type-resultt.html)\n -  [\u0060\u0060ChoiceT\u003C\u0027Monad\u003CChoice\u003C\u0027T,\u0027TError\u003E\u003E\u0060\u0060](type-choicet.html)\n -  [\u0060\u0060Free\u003C\u0027Functor\u003C\u0027T\u003E,\u0027T\u003E\u0060\u0060](type-free.html)\n -  [\u0060\u0060NonEmptyList\u003C\u0027T\u003E\u0060\u0060](type-nonempty.html)\n -  [\u0060\u0060Validation\u003C\u0027Error,\u0027T\u003E\u0060\u0060](type-validation.html)\n -  [\u0060\u0060ZipList\u003C\u0027T\u003E\u0060\u0060](type-ziplist.html)\n -  [\u0060\u0060ParallelArray\u003C\u0027T\u003E\u0060\u0060](type-parallelarray.html)\n -  [\u0060\u0060Const\u003C\u0027C,\u0027T\u003E\u0060\u0060](type-const.html)\n -  [\u0060\u0060Compose\u003C\u0027Applicative1\u003C\u0027Applicative2\u003C\u0027T\u003E\u003E\u003E\u0060\u0060](type-compose.html)\n -  [\u0060\u0060DList\u003C\u0027T\u003E\u0060\u0060](type-dlist.html)\n -  [\u0060\u0060Vector\u003C\u0027T,\u0027Dimension\u003E\u0060\u0060](type-vector.html)\n -  [\u0060\u0060Matrix\u003C\u0027T,\u0027Rows,\u0027Columns\u003E\u0060\u0060](type-matrix.html)\n \nRestricted:\n -  \u0060\u0060string\u0060\u0060\n -  \u0060\u0060StringBuilder\u0060\u0060\n -  \u0060\u0060Set\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060IEnumerator\u003C\u0027T\u003E\u0060\u0060\n\n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n\nExamples\n--------\n*)\n\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\nopen FSharpPlus.Data\n\n// Apply \u002B4 to a list\nlet lst5n6  = map ((\u002B) 4) [ 1;2 ]\n\n// Apply \u002B4 to an array\nlet arr5n6  = map ((\u002B) 4) [|1;2|]\n\n// I could have written this\nlet arr5n6\u0027 = (\u002B) \u003C!\u003E [|4|] \u003C*\u003E [|1;2|]\n\n// Add two options\nlet opt120  = (\u002B) \u003C!\u003E Some 20 \u003C*\u003E tryParse \u0022100\u0022\n\n\n// Applicatives need Return (result)\n\n// Test return\nlet resSome22 : option\u003C_\u003E = result 22\nlet resSing22 : list\u003C_\u003E   = result 22\nlet resLazy22 : Lazy\u003C_\u003E   = result 22\nlet (quot5 : Microsoft.FSharp.Quotations.Expr\u003Cint\u003E) = result 5\n\n// Example\ntype Person = { Name: string; Age: int } with static member create n a = { Name = n; Age = a }\n\nlet person1 = Person.create \u003C!\u003E tryHead [\u0022gus\u0022] \u003C*\u003E tryParse \u002242\u0022\nlet person2 = Person.create \u003C!\u003E tryHead [\u0022gus\u0022] \u003C*\u003E tryParse \u0022fourty two\u0022\nlet person3 = Person.create \u003C!\u003E tryHead [\u0022gus\u0022] \u003C*\u003E (tryHead [\u002242\u0022] \u003E\u003E= tryParse)\n\n\n// Other ways to write applicative expressions\n\n\n// Function lift2 helps in many cases\n\nlet person1\u0027 = (tryHead [\u0022gus\u0022], tryParse \u002242\u0022)               ||\u003E lift2 Person.create \nlet person2\u0027 = (tryHead [\u0022gus\u0022], tryParse \u0022fourty two\u0022)       ||\u003E lift2 Person.create \nlet person3\u0027 = (tryHead [\u0022gus\u0022], tryHead [\u002242\u0022] \u003E\u003E= tryParse) ||\u003E lift2 Person.create \n\n\n// Using Idiom brackets from http://www.haskell.org/haskellwiki/Idiom_brackets\n\nlet res3n4   = iI ((\u002B) 2) [1;2] Ii\nlet res3n4\u0027  = iI (\u002B) (result 2) [1;2] Ii\nlet res18n24 = iI (\u002B) (ZipList(seq [8;4])) (ZipList(seq [10;20])) Ii\n\nlet tryDiv x y = if y = 0 then None else Some (x \u003C/div/\u003E y)\nlet resSome3   = join (iI tryDiv (Some 6) (Some 2) Ii)\nlet resSome3\u0027  =       iI tryDiv (Some 6) (Some 2) Ji\n\nlet tryDivBy y = if y = 0 then None else Some (fun x -\u003E x \u003C/div/\u003E y)\nlet resSome2  = join (result tryDivBy  \u003C*\u003E Some 4) \u003C*\u003E Some 8\nlet resSome2\u0027 = join (   iI tryDivBy (Some 4) Ii) \u003C*\u003E Some 8\n\nlet resSome2\u0027\u0027 = iI tryDivBy (Some 4) J (Some 8) Ii\nlet resNone    = iI tryDivBy (Some 0) J (Some 8) Ii\nlet res16n17   = iI (\u002B) (iI (\u002B) (result 4) [2; 3] Ii) [10] Ii\n\nlet opt121  = iI (\u002B) (Some 21) (tryParse \u0022100\u0022) Ii\nlet opt122  = iI tryDiv (tryParse \u0022488\u0022) (trySqrt 16) Ji\n\n\n// Using applicative math operators\n\nopen FSharpPlus.Math.Applicative\n\nlet opt121\u0027  = Some 21 .\u002B. tryParse \u0022100\u0022\nlet optTrue  = 30 \u003E. tryParse \u002229\u0022\nlet optFalse = tryParse \u002230\u0022 .\u003C 29\nlet m1m2m3 = -.[1;2;3]\n\n\n// Using applicative computation expression\n\nlet getName s = tryHead s\nlet getAge  s = tryParse s\n\nlet person4 = applicative {\n    let! name = getName [\u0022gus\u0022]\n    and! age  = getAge \u002242\u0022\n    return { Name = name; Age = age } }\n\n\n(**\n\nComposing applicatives\n----------------------\n\nUnlike monads, applicatives are always composable.\n\nThe date type [\u0060\u0060Compose\u003C\u0027Applicative1\u003C\u0027Applicative2\u003C\u0027T\u003E\u003E\u003E\u0060\u0060](type-compose.html) can be used to compose any 2 applicatives:\n*)\n\nlet res4 = (\u002B) \u003C!\u003E Compose [Some 3] \u003C*\u003E Compose [Some 1]\n\nlet getNameAsync s = async { return tryHead s }\nlet getAgeAsync  s = async { return tryParse s }\n\nlet person5 = Person.create \u003C!\u003E Compose (getNameAsync [\u0022gus\u0022]) \u003C*\u003E Compose (getAgeAsync \u002242\u0022)\n\n(**\n\nThe computation expressions applicative2 and applicative3 can also be used to compose applicatives:\n*)\n\nlet person6 = applicative2 {\n    let! name = printfn \u0022aa\u0022; getNameAsync [\u0022gus\u0022]\n    and! age  = getAgeAsync \u002242\u0022\n    return { Name = name; Age = age } }\n\n\n\n\n// A Monad is automatically an Applicative\n\ntype MyList\u003C\u0027s\u003E = MyList of \u0027s seq with\n    static member Return (x:\u0027a)     = MyList (Seq.singleton x)\n    static member (\u003E\u003E=)  (MyList x: MyList\u003C\u0027T\u003E, f) = MyList (Seq.collect (f \u003E\u003E (fun (MyList x) -\u003E x)) x)\n\nlet mappedMyList : MyList\u003C_\u003E = (MyList [(\u002B) 1;(\u002B) 2;(\u002B) 3]) \u003C*\u003E (MyList [1;2;3])"},{"uri":"/FSharpPlus/type-matrix.html","title":"Matrix\u003C\u0027NumType,\u0027Rows,\u0027Cols\u003E\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n#r @\u0022../../src/FSharpPlus.TypeLevel/bin/Release/netstandard2.0/FSharpPlus.TypeLevel.dll\u0022\n\n(**\nMatrix\u003C\u0027NumType,\u0027Rows,\u0027Cols\u003E\n========================================\n\nThis is a fixed size matrix of a (typically) numeric type.\n\nRelated Tyes\n------------\n\n - [Vector](type-vector.html): Similar but for vectors\n \n\n\n\nAbstractions\n------------\n\n -  [Semigroup](abstraction-semigroup.html)\n -  [Monoid](abstraction-monoid.html)\n -  [Functor](abstraction-functor.html)\n -  [Applicative](abstraction-applicative.html)\n\n\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n#r @\u0022nuget: FSharpPlus.TypeLevel\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\nopen FSharpPlus.Data\n\nlet matrix3x4_1 =\n    matrix (\n      (1, 0, 0, 0),\n      (0, 1, 0, 0),\n      (0, 0, 0, 0)\n    )\n\nlet matrix3x4_2 =\n    matrix (\n      (10, 0, 100, 0),\n      (30, 1, 100, 0),\n      (60, 0, 100, 0)\n    )\n\n\n// Add two matrices\n\nlet matrix3x4_sum = matrix3x4_1 \u002B matrix3x4_2\n\n\n// Add a scalar\n\nlet matrix3x4_3 = matrix3x4_1 \u002B result 5\n\n\n// Another way\n\nopen FSharpPlus.Math.Generic\n\nlet vector3d_4 = matrix3x4_1 \u002B 5G"},{"uri":"/FSharpPlus/type-mult.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/type-const.html","title":"Const\u003C\u0027T,\u0027U\u003E\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nConst\u003C\u0027T,\u0027U\u003E\n============\n\nThe Const functor, defined as Const\u0026lt;\u0026#39;T, \u0026#39;U\u0026gt; where \u0026#39;U is a phantom type. Useful for: Lens getters Its applicative instance plays a fundamental role in Lens.\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\nopen FSharpPlus.Lens\nopen FSharpPlus.Data\n// note for instance the definition of view (from the Lens part of F#\u002B):\nlet view (optic: (\u0027a -\u003E Const\u003C_,\u0027b\u003E) -\u003E _ -\u003E Const\u003C_,\u0027t\u003E) (source: \u0027s) : \u0027a = Const.run (optic Const source)"},{"uri":"/FSharpPlus/types.html","title":"Types\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n(**\n\nTypes\n=====\n\nClick on the type name for a full description:\n\n \n * [All](type-all.html)\n * [Any](type-any.html)\n * [ChoiceT](type-choicet.html)\n * [Compose](type-compose.html)\n * [Const](type-const.html)\n * [Cont](type-cont.html)\n * [ContT](type-contt.html)\n * [Coproduct](type-coproduct.html)\n * [DList](type-dlist.html)\n * [Dual](type-dual.html)\n * [Endo](type-endo.html)\n * [First](type-first.html)\n * [Free](type-free.html)\n * [Identity](type-identity.html)\n * [Kleisli](type-kleisli.html)\n * [Last](type-last.html)\n * [ListT](type-listt.html)\n * [Mult](type-mult.html)\n * [NonEmptyList](type-nonempty.html)\n * [OptionT](type-optiont.html)\n * [ParallelArray](type-parallelarray.html)\n * [Reader](type-reader.html)\n * [ReaderT](type-readert.html)\n * [ResultT](type-resultt.html)\n * [SeqT](type-seqt.html)\n * [State](type-state.html)\n * [StateT](type-statet.html)\n * [Validation](type-validation.html)\n * [Writer](type-writer.html)\n * [WriterT](type-writert.html)\n * [ZipList](type-ziplist.html)\n*)"},{"uri":"/FSharpPlus/type-nonempty-set.html","title":"NonEmptySet\u003C\u0027T\u003E\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nNonEmptySet\u003C\u0027T\u003E\n================\n\nA type-safe set that contains at least one element.\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\nopen FSharpPlus.Data\n\n(**\n### Constructing NonEmptySet\n*)\n// you can construct a NonEmptySet by using NonEmptySet.Create\nlet set123 = NonEmptySet.Create(1, 2, 3)\n\nlet set4 = NonEmptySet.singleton 4\nlet set4\u0027 : NonEmptySet\u003Cint\u003E = result 4\n\n// union two NonEmptySets\nlet set1234 = NonEmptySet.union set123 set4\n\n// in order to get back to a regular set you can then use NonEmptySet.toSet:\nlet set1234\u0027 = NonEmptySet.toSet set1234\n\n\n(**\n### Operations on NonEmptySet\n*)\n\nlet set12345 = set1234 |\u003E NonEmptySet.add 5\n\nlet set12345\u0027 = NonEmptySet.unionMany (NonEmptyList.create set123 [set4; result 5])\n\nprintfn \u0022%b\u0022 (NonEmptySet.isSubset set1234 set12345)\n\n"},{"uri":"/FSharpPlus/type-statet.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/type-resultt.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/operators-common.html","title":"Operators - Common Combinators\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\nopen FSharpPlus\n\n(**\n# Operators - Common Combinators\n\nThese generic functions and operators are used commonly and are not part\nof any other abstraction.\n\nYou can find these in the API docs: [Operators.fs](reference/operators.html)\n\n## flip\n\nCreates a new function with first two arguments flipped.\n\n\n## konst\n\nCreate a function that always returns the given argument.\nThis is known as a \u0027constant\u0027 function.\n\nThis is commonly useful where a function is required as a parameter\nfor flexibility, but isn\u0027t required in a specific instance.\n\nexample:\n*)\nlet a = [1;2;3] |\u003E filter (konst true);; \n// val a : int list = [1; 2; 3]\n\n(**\n## curry, uncurry, curryN, uncurryN\n\nCurrying is the process of taking a function expecting a tuple, and returning a\nfunction with the same number of arguments as the tuple size.\n\nUncurrying is the reverse process.\n\nThere is \u0060curry\u0060 and \u0060uncurry\u0060 that work on two arguments each, while \u0060curryN\u0060\nand \u0060uncurryN\u0060 work on any number.\n\nexample:\n*)\nlet addThreeNums (x, y, z) = x \u002B y \u002B z;;\n// val addThreeNums : x:int * y:int * z:int -\u003E int\n\nlet b = curryN addThreeNums 1 2 3;;\n// val it : int = 6\n\n(**\n## Functions as operators - \u003C/ /\u003E\n\nA pair of operators \u0060\u003C/\u0060 and \u0060/\u003E\u0060 are defined to allow any function to be used as\nan operator. It will flip the args of your function so that it makes sense when\nthe first argument is coming from the left-hand-side.\n\nexample:\n*)\nlet biggerThan a b = a \u003E b;;\n// val biggerThan : a:\u0027a -\u003E b:\u0027a -\u003E bool when \u0027a : comparison\n\nlet c = 10 \u003C/biggerThan/\u003E 3;;\n// val c : bool = true\n\n(**\n## tap\n\nTap executes a side-effect function, then returns the original input value.\nConsider this as \u0027tapping into\u0027 a chain of functions.\n\nexample:\n*)\n// a pipeline of functions, with a tap in the middle\nlet names = [\u0022John\u0022; \u0022Smith\u0022]\nnames |\u003E map String.toUpper |\u003E tap (printfn \u0022%A\u0022) |\u003E map String.toLower;;\n\n// prints this:\n// [\u0022JOHN\u0022; \u0022SMITH\u0022]\n\n// but returns this:\n// val it : string list = [\u0022john\u0022; \u0022smith\u0022]\n\n(**\n## either\n\nExtracts the value inside a Result from either side - whether Ok or Error.\n\nIt takes a pair of functions:\n\n * fOk - a function applied to the source if it contains an Ok value\n * fError - a function applied to the source if it contains an Error value\n\n...and the source:\n\n * source - the source value containing an Ok or Error\n\n*)\nlet myResult = Ok \u0022I am ok!\u0022;;\n// val myResult : Result\u003Cstring,\u0027a\u003E\n\nlet myOther = Error -1;;\n// val myOther : Result\u003C\u0027a,int\u003E\n\nlet d = either id id myResult;;\n// val d : string = \u0022I am ok!\u0022\n\nlet e = either id id myOther;;\n// val e : int = -1\n\n(**\nDon\u0027t confuse the \u0060either\u0060 function with \u0060result\u0060 which lifts a value into a\nFunctor, just like \u0060return\u0060 when in a computation expression.\n\n\n## option\n\nTakes a function, a default value and a option value. If the option value is None, the function returns the default value.\nOtherwise, it applies the function to the value inside Some and returns the result.\n*)\nlet inline option f n = function Some x -\u003E f x | None -\u003E n\n\n(**\n\n## tuple2, tuple3, ...tuple8\n\nFunctions that generate a tuple. The number indicates the number of arguments\nthat are defined, and the corresponding size of tuple.\n\n*)\nlet inline tuple2 a b             = a,b\nlet inline tuple3 a b c           = a,b,c\nlet inline tuple4 a b c d         = a,b,c,d\nlet inline tuple5 a b c d e       = a,b,c,d,e\nlet inline tuple6 a b c d e f     = a,b,c,d,e,f\nlet inline tuple7 a b c d e f g   = a,b,c,d,e,f,g\nlet inline tuple8 a b c d e f g h = a,b,c,d,e,f,g,h\n\n\n(**\n## Explicit\n\nExplicit allows you to use \u0060explicit\u0060 generic method for standard types and types that implement the static explicit type cast signature.\n\n### Minimal definition\n\nIn order to use the \u0060explicit\u0060 generic method together with a type it needs to implement the following:\n*)\n\n(**\n\u0060\u0060\u0060f#\nstatic member op_Explicit (x:\u0027r) :\u0027T\n\u0060\u0060\u0060\nor in C#\n\u0060\u0060\u0060c#\npublic static explicit operator T(R s)\n\u0060\u0060\u0060\n\nThis is useful when dealing with C# libraries that make heavy use of explicit conversions.\n*)\n\n(**\n## Implicit\n\nImplicit allows you to use \u0060implicit\u0060 generic method for standard types and types that implement the static implicit type cast signature.\n\n### Minimal definition\n\nIn order to use the \u0060implicit\u0060 generic method together with a type it needs to implement the following:\n*)\n\n(**\n\u0060\u0060\u0060f#\nstatic member op_Implicit (x:\u0027r) :\u0027T\n\u0060\u0060\u0060\nor in C#\n\u0060\u0060\u0060c#\npublic static implicit operator T(R s)\n\u0060\u0060\u0060\n\nThis is useful when dealing with C# libraries that make heavy use of implicit conversions.\n*)"},{"uri":"/FSharpPlus/type-kleisli.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/abstraction-profunctor.html","title":"Profunctor\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nProfunctor\n==========\n\nA bifunctor that is a contravariant in the first argument and covariant in the second.\n\n___\n\n\n\nMinimal complete definition\n---------------------------\n\n\n * \u0060\u0060dimap f g x\u0060\u0060\n*)\n(**\n    static member Dimap (x:\u0027Profunctor\u003C\u0027T,\u0027V\u003E, f:\u0027U-\u003E\u0027T, g:\u0027V-\u003E\u0027W) :\u0027Profunctor\u003C\u0027U,\u0027W\u003E\n*)\n(**\n\n\nOther operations\n----------------\n\n * \u0060\u0060lmap f x\u0060\u0060\n*)\n(**\n    static member Contramap (x:Profunctor\u003C\u0027T,\u0027V\u003E, f:\u0027U-\u003E\u0027T) :\u0027Profunctor\u003C\u0027U,\u0027V\u003E\n*)\n(**\n\n * \u0060\u0060rmap g x\u0060\u0060\n*)\n(**\n    static member Map (x:Profunctor\u003C\u0027T,\u0027V\u003E, f:\u0027V-\u003E\u0027W) :\u0027Profunctor\u003C\u0027T,\u0027W\u003E\n*)\n(**\n\n\n\n\nRules\n-----\n*)\n(**\n    dimap id id = id\n    dimap (h\u0027 \u003C\u003C h) (f \u003C\u003C f\u0027) = dimap h f \u003C\u003C dimap h\u0027 f\u0027\n*)\n(**\n\n\nRelated Abstractions\n--------------------\n\n - [Functor](abstraction-functor.html): All profunctors are also functors over the second parameter.\n\n\nConcrete implementations\n------------------------\n\nFrom .Net/F#\n \n -  \u0060\u0060(\u0027T -\u003E \u0027U)\u0060\u0060\n -  \u0060\u0060Func\u003C\u0027T,\u0027U\u003E\u0060\u0060\n\nFrom F#\u002B\n\n -  [\u0060\u0060Kleisli\u003C\u0027T, \u0027Monad\u003C\u0027U\u003E\u003E\u0060\u0060](type-kleisli.html)\n\n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n\nExamples\n--------\n*)\n\n\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\nopen System\nopen FSharpPlus\nopen FSharpPlus.Data\nopen FSharpPlus.Math.Generic\n\nmodule Predicate = let run (p: Predicate\u003C_\u003E) x = p.Invoke (x)\n\nlet isEven       = Predicate (fun x -\u003E x % 2 = 0)\n\nlet resStrFalse  = dimap int string (Predicate.run isEven) 99.0\n\n\nlet lx x = Char.GetNumericValue x \u002B 100.\nlet rx x = string (x \u002B 100)\nlet kl = Kleisli (fun (y:float) -\u003E [int y; int y * 2 ; int y * 3])\n\nlet resl = lmap lx kl\nlet r105n210n315 = Kleisli.run resl \u00275\u0027\nlet resr = rmap rx kl\nlet r105n110n115 = Kleisli.run resr 5.0\nlet resd = dimap lx rx kl\nlet r205n310n415 = Kleisli.run resd \u00275\u0027"},{"uri":"/FSharpPlus/type-all.html","title":"All\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nAll\n===\n\nThis is a wrapper type for booleans, with a specific set of monoidal operations.\nThe contained bools would become true only if both (all) operands are true.\n\nRelated Types\n------------\n\n - [Any](type-any.html): Similar wrapper, but using the \u0027any\u0027 criteria.\n\n\nAbstractions\n------------\n\n -  [Semigroup](abstraction-semigroup.html)\n -  [Monoid](abstraction-monoid.html)\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\nopen FSharpPlus.Data\n\nlet res1 = All true \u002B\u002B zero \u002B\u002B All false\n// val res1 : All = All false\n\nlet even x = x % 2 = 0\n\nlet res2 = [2;4;6;7;8] |\u003E map (even \u003E\u003E All) |\u003E sum\n// val res2 : All = All false"},{"uri":"/FSharpPlus/type-valueoptiont.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/type-last.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/type-coproduct.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/abstractions.html","title":"Abstractions\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n(**\n\nAbstractions\n============\n\nThe following diagram illustrates some common FP abstractions that can be represented with this library and the relationships between them.\n\nClick on the abstraction name for a full description:\n\n\u003Cobject style=\u0022width: 100%\u0022 data=\u0022//www.plantuml.com/plantuml/svg/{plantUMLDiag}\u0022 type=\u0022image/svg\u002Bxml\u0022\u003E\u003C/object\u003E\n \n\nSome more abstractions [here](abstraction-misc.html).\n\n*)"},{"uri":"/FSharpPlus/type-contt.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/applicative-functors.html","title":"Functors and Applicatives\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nFunctors and Applicatives\n=========================\n\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\n\n(**\n\nYou may run this script step-by-step\nThe order of execution has to be respected since there are redefinitions of functions and operators\n\n\nFunctors\n========\n\nThe intuitive definition is that a Functor is something you can map over.\n\nSo they all have a \u0060\u0060map\u0060\u0060 operation which is their minimal definition.\n\nMost containers are functors\n*)\n\nlet r01 = List.map   (fun x -\u003E string (x \u002B 10)) [ 1;2;3 ]\nlet r02 = Array.map  (fun x -\u003E string (x \u002B 10)) [|1;2;3|]\nlet r03 = Option.map (fun x -\u003E string (x \u002B 10)) (Some 5)\n\n(**\nYou can think of the Option functor as a particular case of a List that can be either empty or with just 1 element.\n\nWe could have used the generic function \u0060\u0060map\u0060\u0060 from this library which works on any functor.\n\n*)\n\nlet r01\u0027 = map (fun x -\u003E string (x \u002B 10)) [ 1;2;3 ]\nlet r02\u0027 = map (fun x -\u003E string (x \u002B 10)) [|1;2;3|]\nlet r03\u0027 = map (fun x -\u003E string (x \u002B 10)) (Some 5)\n\n(** Now let\u0027s define a simple type and make it a functor by adding a \u0060\u0060Map\u0060\u0060 static method *)\n\ntype Id\u003C\u0027t\u003E = Id of \u0027t with\n    static member Map (Id x, f) = Id (f x)\n\nlet r04 = map (fun x -\u003E string (x \u002B 10)) (Id 5)\n\n(**\nMost computations are also functors\n\nHere\u0027s an example with Async functions\n*)\n\nlet async5 = async.Return 5\nlet r05  = map (fun x -\u003E string (x \u002B 10)) async5\nlet r05\u0027 = Async.RunSynchronously r05\n\n\n(** But even plain functions are functors *)\n\nlet r06  = map (fun x -\u003E string (x \u002B 10)) ((\u002B) 2)\nlet r06\u0027 = r06 3\n\n(**\nFor functions \u0060\u0060map\u0060\u0060 is equivalent to \u0060\u0060(\u003C\u003C)\u0060\u0060 this means that mapping over a function is the same as composing the functions with the mapper\n\nA List functor can be thought of as a function which takes an integer index to return a value: \u0060\u0060f: Naturals -\u003E \u0027t\u0060\u0060\nSo, you can think of \u0060\u0060map\u0060\u0060 on a List functor as composing a function:\n\n**)\nlet listFunc = function 0 -\u003E 1 | 1 -\u003E 2 | 2 -\u003E 3 // [1;2;3]\nlet r01\u0027\u0027 = map (fun x -\u003E string (x \u002B 10)) listFunc\n\n(**\nWhat about tuples?\n**)\n\nmodule TupleFst = let map f (a,b) = (f a, b)\nmodule TupleSnd = let map f (a,b) = (a, f b)\n\nlet r07 = TupleFst.map (fun x -\u003E string (x \u002B 10)) (5, \u0022something else\u0022)\nlet r08 = TupleSnd.map (fun x -\u003E string (x \u002B 10)) (\u0022something else\u0022, 5)\n\n(**\nSo there is more than one way to define a functor with tuples.\nThe same applies to the Discriminated Union of 2 types.\n*)\n\n// DUs\nmodule ChoiceFst = let map f = function Choice1Of2 x -\u003E Choice1Of2 (f x) | Choice2Of2 x -\u003E Choice2Of2 x\nmodule ChoiceSnd = let map f = function Choice2Of2 x -\u003E Choice2Of2 (f x) | Choice1Of2 x -\u003E Choice1Of2 x\n\nlet choiceValue1:Choice\u003Cint,string\u003E = Choice1Of2 5\nlet choiceValue2:Choice\u003Cint,string\u003E = Choice2Of2 \u0022Can\u0027t divide by zero.\u0022\n\nlet r09  = ChoiceFst.map (fun x -\u003E string (x \u002B 10)) choiceValue1\nlet r09\u0027 = ChoiceFst.map (fun x -\u003E string (x \u002B 10)) choiceValue2\n\nlet r10  = ChoiceSnd.map (fun x -\u003E \u0022The error was: \u0022 \u002B x) choiceValue1\nlet r10\u0027 = ChoiceSnd.map (fun x -\u003E \u0022The error was: \u0022 \u002B x) choiceValue2\n\n\n(** Tree as a functor *)\n\ntype Tree\u003C\u0027a\u003E =\n    | Tree of \u0027a * Tree\u003C\u0027a\u003E * Tree\u003C\u0027a\u003E\n    | Leaf of \u0027a\n\nmodule Tree = let rec map f = function \n                | Leaf x        -\u003E Leaf (f x) \n                | Tree(x,t1,t2) -\u003E Tree(f x, map f t1, map f t2)\n\nlet myTree = Tree(6, Tree(2, Leaf 1, Leaf 3), Leaf 9)\n\nlet r11 = Tree.map (fun x -\u003E string (x \u002B 10)) myTree\n\n(**\nQ: is String a Functor?\n*)\n\nlet r12 = String.map (fun c -\u003E System.Char.ToUpper(c)) \u0022Hello world\u0022\n\n(**\nA: Kind of, but we can\u0027t change the wrapped type. We\u0027re stick to (\u0027a-\u003E\u0027a) -\u003E C\u003C\u0027a\u003E -\u003E C\u003C\u0027a\u003E \n   if we assume \u0027a = char and C\u003C\u0027a\u003E = String\n\n\nFinally there are some laws:\n\n - \u0060\u0060map id = id\u0060\u0060\n - \u0060\u0060map (f \u003E\u003E g) = map f \u003E\u003E map g\u0060\u0060\n\n\n\nLimitations:\n\nWe can define \u0060\u0060map2\u0060\u0060 then \u0060\u0060map3\u0060\u0060  then ..  \u0060\u0060mapN\u0060\u0060 ?\n\n*)\n\ntype Option\u003C\u0027T\u003E with\n    static member map2 f x y = \n        match x, y with\n        | Some x, Some y -\u003E Some (f x y)\n        | _              -\u003E None\n\n    static member map3 f x y z = \n        match x, y, z with\n        | Some x, Some y, Some z -\u003E Some (f x y z)\n        | _                      -\u003E None\n\nlet r13 = Option.map2 (\u002B) (Some 2) (Some 3)\n\nlet r14 = List.map2 (\u002B) [1;2;3] [10;11;12]\n\nlet add3 a b c = a \u002B b \u002B c\n\nlet r15 = Option.map3 add3 (Some 2) (Some 2) (Some 1)\n\n(**\n\nQuestion: Is it possible to generalize to mapN?\n\n\nApplicative Functors\n====================\n\nWhat if we split \u0060\u0060map\u0060\u0060 in 2 steps?\n\n*)\n\n// map (\u0027a -\u003E \u0027b) -\u003E C\u003C\u0027a\u003E -\u003E C\u003C\u0027b\u003E\n//     \\--------/    \\---/    \\---/\n//         (a)        (b)      (c)\n//\n// 1)    (\u0027a -\u003E \u0027b)        -\u003E  C\u003C\u0027a -\u003E \u0027b\u003E\n//       \\--------/            \\---------/\n//           (a)                      \n//               \n// 2)  C\u003C\u0027a -\u003E \u0027b\u003E -\u003E C\u003C\u0027a\u003E  -\u003E   C\u003C\u0027b\u003E\n//     \\---------/    \\---/       \\---/\n//                     (b)         (c)\n//\n//\n// step1   (\u0027a -\u003E \u0027b)        -\u003E  \u0022C\u003C\u0027a -\u003E \u0027b\u003E\u0022      Put the function into a context C\n// step2 \u0022C\u003C\u0027a -\u003E \u0027b\u003E\u0022 C\u003C\u0027a\u003E -\u003E   C\u003C\u0027b\u003E             Apply the function in a context C to a value in a context C\n\n(** Here\u0027s an example with Options *)\n\nlet step1 f = Some f\nlet step2 a b = \n    match a, b with\n    | Some f, Some x -\u003E Some (f x)\n    | _              -\u003E None\n\nlet r16 = step1 (fun x -\u003E string (x \u002B 10))\nlet r17 = step2 r16 (Some 5)\n\n    \n(** So now instead of writing: *)\n\nlet r18  = Option.map (fun x -\u003E string (x \u002B 10)) (Some 5)\n\n(** we write *)\n\nlet r18\u0027 = step2 (step1 (fun x -\u003E string (x \u002B 10))) (Some 5)\n\n    \n(** and instead of \u0060\u0060map2\u0060\u0060 like this: *)\nlet r19   = Option.map2 (\u002B) (Some 2) (Some 3)\n\n(** we write *)\nlet r19i  = step2 (step1 (\u002B)) (Some 2)\n(** .. and finally *)\nlet r19\u0027 = step2 r19i (Some 3)\n(** by applying \u0060\u0060step2\u0060\u0060 again. We can apply \u0060\u0060step2\u0060\u0060 again if the result is still a function in a container, just like partial application.\n\n\nlets give names to \u0060\u0060step1\u0060\u0060 and \u0060\u0060step2\u0060\u0060: \u0060\u0060pure\u0060\u0060 and \u0060\u0060\u003C*\u003E\u0060\u0060 *)\n\nmodule OptionAsApplicative =\n    let pure\u0027 x = Some x\n    let (\u003C*\u003E) a b = \n        match a, b with\n        | Some f, Some x -\u003E Some (f x)\n        | _              -\u003E None\n\nopen OptionAsApplicative\n\nlet r18\u0027\u0027  = Option.map (fun x -\u003E string (x \u002B 10)) (Some 5)\n\nlet r18\u0027\u0027\u0027 = Some (fun x -\u003E string (x \u002B 10)) \u003C*\u003E Some 5\n// analog to:\nlet r18\u0027\u0027\u0027\u0027 =     (fun x -\u003E string (x \u002B 10))          5\n\n\n(** Now with \u0060\u0060map3\u0060\u0060 (and further with mapN) *)\n\nlet r20 = Option.map3 add3 (Some 2) (Some 2) (Some 1)\n\nlet r20\u0027  = Some add3 \u003C*\u003E Some 2 \u003C*\u003E Some 2 \u003C*\u003E Some 1\n// analog to:\nlet r20\u0027\u0027  =     add3          2          2          1\n\n\n(** but even without \u0060\u0060add3\u0060\u0060 we can write \u0060\u00601 \u002B 2 \u002B 2\u0060\u0060 which is \u0060\u00601 \u002B (2 \u002B 2)\u0060\u0060 and the same as: *)\n\nlet r20\u0027\u0027\u0027  = (\u002B) 1 ((\u002B) 2 2)\n\n(** with options becomes: *)\nlet r20\u0027\u0027\u0027\u0027 = Some (\u002B) \u003C*\u003E Some 1 \u003C*\u003E (Some (\u002B) \u003C*\u003E Some 2 \u003C*\u003E Some 2)\n(** constrast it with *)\nlet r20\u0027\u0027\u0027\u0027\u0027  =    (\u002B)          1     (     (\u002B)          2          2)\n\n(** we know \u0060\u0060apply\u0060\u0060 is \u0060\u0060(\u003C|)\u0060\u0060 in F# *)\n\nlet r21     =      (\u002B) \u003C|       1 \u003C|  (     (\u002B) \u003C|       2 \u003C|       2)\nlet r21\u0027    = Some (\u002B) \u003C*\u003E Some 1 \u003C*\u003E (Some (\u002B) \u003C*\u003E Some 2 \u003C*\u003E Some 2)\n\n(**\nSo at this point the name \u0022Applicative Functor\u0022 should make sense\n    \nQ: Isn\u0027t it easier to do just \u0060\u0060Some ( (\u002B) 1 ((\u002B) 2 2) )\u0060\u0060 ?\n   We get the same result in the end.\nA: Yes, in this particular case it\u0027s the same but what if instead of \u0060\u0060Some 1\u0060\u0060 we have \u0060\u0060None\u0060\u0060\n*)\n\nlet r22   = Some (\u002B) \u003C*\u003E None \u003C*\u003E (Some (\u002B) \u003C*\u003E Some 2 \u003C*\u003E Some 2)\n\n(**   \nThat\u0027s because we\u0027re applying functions inside a context.\n\nIt looks the same as applying outside but in fact some effects occurs behind the scenes.\n\nTo have a better idea let\u0027s move out of Option:\n*)\n\n[\u003CAutoOpen\u003E]\nmodule Async =\n    let pure\u0027 x = async.Return x\n    let (\u003C*\u003E) f x = async.Bind(f, fun x1 -\u003E async.Bind(x, fun x2 -\u003E pure\u0027(x1 x2)))\n\n    \nlet r23   = async {return (\u002B)} \u003C*\u003E async {return 2} \u003C*\u003E async {return 3}\n\nlet r23\u0027  = pure\u0027 (\u002B) \u003C*\u003E pure\u0027 2 \u003C*\u003E pure\u0027 3\n\n(** try \u0060\u0060Async.RunSynchronously r23\u0027\u0060\u0060 *)\n\nlet getLine = async { \n        let x = System.Console.ReadLine() \n        return  System.Int32.Parse x\n    }\n\nlet r24  = pure\u0027 (\u002B) \u003C*\u003E getLine \u003C*\u003E getLine\n\n(** try \u0060\u0060Async.RunSynchronously r24\u0060\u0060 *)\n\n\nmodule ListAsApplicative =\n    let pure\u0027 x = [x]        \n    let (\u003C*\u003E)  f x = List.collect (fun x1 -\u003E List.collect (fun x2 -\u003E [x1 x2]) x) f\n\n    (* here are two other possible implementations of (\u003C*\u003E) for List\n    let (\u003C*\u003E) f x = f |\u003E List.map (fun f -\u003E x |\u003E List.map (fun x -\u003E f x)) |\u003E List.concat\n    let (\u003C*\u003E) f x= \n        seq {\n                for f in f do\n                for x in x do\n                yield f x} |\u003E Seq.toList *)\n\nopen ListAsApplicative\n\nlet r25 =  List.map (fun x -\u003E string (x \u002B 10)) [1;2;3]\n\nlet r25\u0027  =       [fun x -\u003E string (x \u002B 10)] \u003C*\u003E [1..3]\nlet r25\u0027\u0027 = pure\u0027 (fun x -\u003E string (x \u002B 10)) \u003C*\u003E [1..3]\n\n\nlet r26 = [string; fun x -\u003E string (x \u002B 10)] \u003C*\u003E [1;2;3]\n\n(** So, for lists \u0060\u0060map2\u0060\u0060 is equivalent to write: *)\n\nlet r27 = [(\u002B)] \u003C*\u003E [1;2] \u003C*\u003E [10;20;30]\n\nlet r28 = [(\u002B);(-)] \u003C*\u003E [1;2] \u003C*\u003E [10;20;30]\n\n\n    \nmodule SeqAsApplicative =\n    let pure\u0027 x = Seq.initInfinite (fun _ -\u003E x)\n    let (\u003C*\u003E) f x = Seq.zip f x |\u003E Seq.map (fun (f,x) -\u003E f x)\n\nopen SeqAsApplicative\n\n\nlet r29 =  Seq.map (fun x -\u003E string (x \u002B 10))    (seq [1;2;3])          |\u003E Seq.toList\nlet r29\u0027 =   pure\u0027 (fun x -\u003E string (x \u002B 10)) \u003C*\u003E seq [1;2;3]           |\u003E Seq.toList\n    \nlet r30 = seq [(\u002B);(-)] \u003C*\u003E seq [1;2] \u003C*\u003E seq [10;20;30]                |\u003E Seq.toList  // compare it with r28\n\n\n(** An exotic case where there is no \u0060\u0060pure\u0060\u0060. *)\n\nmodule MapAsApplicative = \n    let (\u003C*\u003E) (f:Map\u003C\u0027k,_\u003E) x =\n        Map (seq {\n            for KeyValue(k, vf) in f do\n                match Map.tryFind k x with\n                | Some vx -\u003E yield k, vf vx\n                | _       -\u003E () })\n\n\nopen MapAsApplicative\n\nlet r31 = Map [\u0027a\u0027,(\u002B);\u0027b\u0027,(-)] \u003C*\u003E Map [\u0027a\u0027,1;\u0027b\u0027,2] \u003C*\u003E Map [\u0027a\u0027,10;\u0027b\u0027,20;\u0027c\u0027,30] \n\nlet r32 = Map [\u0027c\u0027,(\u002B);\u0027b\u0027,(-)] \u003C*\u003E Map [\u0027a\u0027,1;\u0027b\u0027,2] \u003C*\u003E Map [\u0027a\u0027,10;\u0027b\u0027,20;\u0027c\u0027,30] \n\n(**\n\nMonads\n======\n\n*)\n\nopen OptionAsApplicative    \n    \nlet a = Some 3\nlet b = Some 2\nlet c = Some 1\n\nlet half x = x / 2        \n\nlet f a b c =\n    let x = a \u002B b\n    let y = half c\n    x \u002B y\n\nlet f\u0027 a b c =\n    let x = Some (\u002B)  \u003C*\u003E a \u003C*\u003E b\n    let y = Some half \u003C*\u003E c\n    Some (\u002B) \u003C*\u003E x \u003C*\u003E y\n    \nlet r33 = f\u0027 (Some 1) (Some 2) (Some 3)\n\nlet r33\u0027 = f\u0027 None (Some 2) (Some 3)\n    \n(** OK, but if I want to use a function like: *)\nlet exactHalf x =\n    if x % 2 = 0 then Some (x / 2)\n    else None\n\n(** It doesn\u0027t fit *)\n\n// let f\u0027\u0027 a b c =\n//     let x = Some (\u002B) \u003C*\u003E a \u003C*\u003E b\n//     let y = Some exactHalf \u003C*\u003E c   // y will be inferred as option\u003Coption\u003Cint\u003E\u003E\n//     Some (\u002B) \u003C*\u003E x \u003C*\u003E y           // so this will not compile\n\n\n(**\nThe problem is, we were working with ordinary functions.\nWhen we lift these function into C, we get functions wrapped in contexts.\nWith Applicatives we can use either a function in a context which is ready to use or an ordinary function, which we can lift easily with \u0060\u0060pure\u0060\u0060.\n\nBut \u0060\u0060exactHalf\u0060\u0060 is a different thing: its signature is \u0060\u0060int -\u003E Option\u003Cint\u003E\u0060\u0060.\nThis function goes from a pure value to a value in a context, so either:\n\n1) we use it directly but we first need to extract the argument from the context.\n\n2) we use it in an Applicative, we will get a value in a context in another context, so we will need to flatten both contexts.\n\nMonad provides solutions to both alternatives\n*)\n\n// bind : C\u003C\u0027a\u003E -\u003E (\u0027a-\u003EC\u003C\u0027b\u003E) -\u003E C\u003C\u0027b\u003E\n// join : C\u003CC\u003C\u0027a\u003E\u003E -\u003E C\u003C\u0027a\u003E\n\nmodule OptionAsMonad =\n    let join  x   = Option.bind id x\n    let (\u003E\u003E=) x f = Option.bind f x\n    // in monads pure\u0027 is called return, unit or result, but it\u0027s essentially the same function.\n    let return\u0027 x = Some x\n        \nopen OptionAsMonad        \n\n\n\nlet f\u0027\u0027 a b c =\n    let x = Some (\u002B) \u003C*\u003E a \u003C*\u003E b\n    let y = Some exactHalf \u003C*\u003E c |\u003E join\n    Some (\u002B) \u003C*\u003E x \u003C*\u003E y\n    \n\nlet f\u0027\u0027\u0027 a b c =\n    let x = Some (\u002B) \u003C*\u003E a \u003C*\u003E b\n    let y = c \u003E\u003E= exactHalf\n    Some (\u002B) \u003C*\u003E x \u003C*\u003E y\n\n(** All monads are automatically applicatives, remember \u0060\u0060\u003C*\u003E\u0060\u0060 for lists, it was:\n\n\u0060\u0060let (\u003C*\u003E)  f x = List.collect (fun x1 -\u003E List.collect (fun x2 -\u003E [x1 x2]) x) f\u0060\u0060 *)\n\n(** But \u0060\u0060List.collect\u0060\u0060 is in fact \u0060\u0060bind\u0060\u0060, and \u0060\u0060[x1 x2]\u0060\u0060 is \u0060\u0060pure (x1 x2)\u0060\u0060 *)\n\n// let (\u003C*\u003E) f x = f \u003E\u003E= (fun x1 -\u003E x \u003E\u003E= (fun x2 -\u003E pure\u0027 (x1 x2)))\n\n(**\n\nAnd this definition of \u0060\u0060\u003C*\u003E\u0060\u0060 applies to all monads.\n\nQ: but we said all applicatives are functors, so monads should be functors as well, right?\nA: Yes, they are, and this is the general definition of \u0060\u0060map\u0060\u0060 based on \u0060\u0060bind\u0060\u0060 and \u0060\u0060result\u0060\u0060 (aka return or pure)\n*)\n\nlet map f x = x \u003E\u003E= (pure\u0027 \u003C\u003C f)\n\n(**\n\nRecommended links\n\nSame explanation but with pictures\nhttp://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html\n\nHaskell typeclasses\nhttp://www.haskell.org/haskellwiki/Typeclassopedia *)"},{"uri":"/FSharpPlus/abstraction-alternative.html","title":"Alternative\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nAlternative\n===========\nApplicative Functors which also have a monoid structure.\n___\nMinimal complete definition\n---------------------------\n * \u0060\u0060return x\u0060\u0060/\u0060\u0060result x\u0060\u0060 \n * \u0060\u0060(\u003C*\u003E) f x\u0060\u0060\n * \u0060\u0060empty\u0060\u0060\n * \u0060\u0060append x y\u0060\u0060/\u0060\u0060(\u003C|\u003E) x y\u0060\u0060\n*)\n(**\n    static member Return (x:\u0027T) : \u0027Alternative\u003C\u0027T\u003E\n    static member (\u003C*\u003E) (f:\u0027T-\u003E\u0027U, x:Alternative\u003C\u0027T\u003E) : Alternative\u003C\u0027U\u003E\n    static member get_Empty () :\u0027Alternative\n    static member (\u003C|\u003E) (x:\u0027Alternative\u003C\u0027T\u003E, y:\u0027Alternative\u003C\u0027T\u003E) :\u0027Alternative\u003C\u0027T\u003E\n*)\n(**\nNote: \u0060\u0060return\u0060\u0060 can\u0027t be used outside computation expressions, use \u0060\u0060result\u0060\u0060 instead.\nOther operations\n----------------\n * \u0060\u0060mfilter\u0060\u0060\n*)\n(**\n    static member MFilter (x:seq\u003C\u0027Alternative\u003E) :\u0027Alternative\n*)\n(**\n * \u0060\u0060choice\u0060\u0060\n*)\n(**\nRules\n-----\n*)\n(**\n    empty \u003C|\u003E x = x\n    x \u003C|\u003E empty = x\n    (x \u003C|\u003E y) \u003C|\u003E z = x \u003C|\u003E (y \u003C|\u003E z)\n    f \u003C!\u003E (x \u003C|\u003E y) = (f \u003C!\u003E x) \u003C|\u003E (f \u003C!\u003E y)\n    (f \u003C|\u003E g) \u003C*\u003E x = (f \u003C*\u003E x) \u003C|\u003E (g \u003C*\u003E x)\n    empty \u003C*\u003E f = empty\n*)\n(**\nRelated Abstractions\n--------------------\n - [Monoid](abstraction-monoid.html): An Alternative is a Monoid that is also an Applicative Functor\n - [Applicative](abstraction-applicative.html): An Alternative is a Monoid that is also an Applicative Functor\n - MonadPlus: Alternatives that are also Monads\nConcrete implementations\n------------------------\nFrom .Net/F#\n \n -  \u0060\u0060list\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060option\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060array\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060seq\u003C\u0027T\u003E\u0060\u0060\n \nFrom F#\u002B\n \n -  [\u0060\u0060ReaderT\u003C\u0027R, \u0027MonadPlus\u003C\u0027T\u003E\u003E\u0060\u0060](type-readert.html)\n -  [\u0060\u0060WriterT\u003C\u0027MonadPlus\u003C\u0027T * \u0027Monoid\u003E\u003E\u0060\u0060](type-writert.html)\n -  [\u0060\u0060StateT\u003C\u0027S,\u0027MonadPlus\u003C\u0027T * \u0027S\u003E\u003E\u0060\u0060](type-statet.html)\n -  [\u0060\u0060Compose\u003C\u0027AlternativeF\u003C\u0027AlternativeG\u003C\u0027T\u003E\u003E\u003E\u0060\u0060](type-compose.html)\n -  [\u0060\u0060DList\u003C\u0027T\u003E\u0060\u0060](type-dlist.html)\n -  [\u0060\u0060ZipList\u003C\u0027S\u003E\u0060\u0060](type-ziplist.html)\n \n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n\nExamples\n--------\n*)\n\n\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\n\n// this gives [2; 3; 4; 5]\nlet x = [2;3] \u003C|\u003E [] \u003C|\u003E [4;5]\n\n// but I could have written\nlet y = [2;3] \u003C|\u003E empty \u003C|\u003E [4;5]\n\n// choice sample usage\nlet alternatives = [None; Some \u0022Result is OK\u0022; None ; Some \u0022Result is still OK\u0022]\nlet firstGood = choice alternatives //Some \u0022Result is OK\u0022\n\n// it did something like\nlet fstGood = None \u003C|\u003E Some \u0022Result is OK\u0022 \u003C|\u003E  None \u003C|\u003E Some \u0022Result is still OK\u0022\n\n// mfilter usage\nlet fstMatch = mfilter ((=) 5) [1;2;3;4]    // [] -\u003E no element found, it uses the empty value\n\n\n// MonadPlus\n\nlet getLine    = async { return System.Console.ReadLine() }\nlet putStrLn x = async { printfn \u0022%s\u0022 x}\n\nlet nameAndAddress = traverse (fun x -\u003E putStrLn x \u003E\u003E= fun _ -\u003E getLine) [\u0022name\u0022;\u0022address\u0022]\n\nlet a:list\u003Cint\u003E = empty\nlet res123      = empty \u003C|\u003E [1;2;3]\n\nlet inline mfilter p ma = monad.plus {\n  let! a = ma\n  if p a then return a else return! empty}\n\nlet mfilterRes2 = mfilter ((=)2) (Some 2)\n\n// sample code from http://en.wikibooks.org/wiki/Haskell/MonadPlus\nlet pythags = monad {\n  let! z = [1..50]\n  let! x = [1..z]\n  let! y = [x..z]\n  do! guard (x*x \u002B y*y = z*z)\n  return (x, y, z)}\n\n// same operation but using the monad.plus computation expression\nlet pythags\u0027 = monad.plus {\n  let! z = [1..50]\n  let! x = [1..z]\n  let! y = [x..z]\n  if (x*x \u002B y*y = z*z) then return (x, y, z) else ()}\n\nlet allCombinations = sequence [[\u0027a\u0027; \u0027b\u0027; \u0027c\u0027]; [\u00271\u0027; \u00272\u0027]]\n\n\n// An Alternative is automatically a Monoid and a Functor\n\ntype Maybe\u003C\u0027t\u003E =\n    | Just of \u0027t\n    | Nothing \n    with\n        static member Return (x:\u0027a)     = Just x\n        static member (\u003C*\u003E) (f, x) = \n            match (f, x) with \n            | Just f, Just x -\u003E Just (f x) \n            | _              -\u003E Nothing\n        static member inline get_Empty () = Nothing\n        static member inline (\u003C|\u003E) (x, y) = match x with Nothing -\u003E y | xs -\u003E xs\n\nlet r5 = Nothing \u002B\u002B Just 5 \u002B\u002B Just 6 \u002B\u002B zero\nlet r6 = map string (Just 6)\n\n\n// But not always the Monoidal behaviour is the same\n\nlet r3 = Some 2 \u002B\u002B Some 1   // addition         =\u003E Some 3\nlet r2 = Some 2 \u003C|\u003E Some 1  // first success    =\u003E Some 2"},{"uri":"/FSharpPlus/abstraction-foldable.html","title":"Foldable\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n(**\nFoldable\n========\n\nData structures that can be folded to a summary value.\n\n___\n\n\n\nMinimal complete definition\n---------------------------\n\n\n * \u0060\u0060toSeq x\u0060\u0060\n*)\n(**\n    static member ToSeq (x:\u0027Foldable\u003C\u0027T\u003E) :seq\u003C\u0027T\u003E\n*)\n(**\n\n\nOther operations\n----------------\n\n * \u0060\u0060foldMap\u0060\u0060\n*)\n(**\n    FoldMap (x:\u0027Foldable\u003C\u0027T\u003E, f:\u0027T-\u003E\u0027Monoid)\n*)\n(**\n\n\nRules\n-----\n*)\n(**\n    foldMap (f \u003E\u003E g) = foldMap f \u003E\u003E g\n*)\n(**\n\n\nRelated Abstractions\n--------------------\n\n - [Monoid](abstraction-monoid.html)\n\n\nConcrete implementations\n------------------------\n\nFrom .Net/F#\n \n -  \u0060\u0060seq\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060list\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060\u0027T []\u0060\u0060\n -  \u0060\u0060option\u003C\u0027T\u003E\u0060\u0060 \n -  \u0060\u0060voption\u003C\u0027T\u003E\u0060\u0060 \n -  \u0060\u0060ResizeArray\u003C\u0027T\u003E\u0060\u0060 \n -  \u0060\u0060ReadOnlyCollection\u003C\u0027T\u003E\u0060\u0060 \n -  \u0060\u0060IReadOnlyCollection\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060IReadOnlyList\u003C\u0027T\u003E\u0060\u0060\n\n \nFrom F#\u002B\n\n -  [\u0060\u0060ZipList\u003C\u0027T\u003E\u0060\u0060](type-ziplist.html)\n -  [\u0060\u0060NonEmptyList\u003C\u0027S\u003E\u0060\u0060](type-nonempty.html)\n -  [\u0060\u0060DList\u003C\u0027T\u003E\u0060\u0060](type-dlist.html)\n\n\n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n\nExamples\n--------\n*)\n\n\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\nopen FSharpPlus\nopen FSharpPlus.Data\nopen FSharpPlus.Control\n\nlet res1_Gt   = foldMap (compare 2) [1;2;3]\nlet resHelloW = foldMap (fun x -\u003E Some (\u0022hello \u0022 \u002B x)) (Some \u0022world\u0022)\n\nmodule FoldableTree =\n    type Tree\u003C\u0027a\u003E =\n        | Empty \n        | Leaf of \u0027a \n        | Node of (Tree\u003C\u0027a\u003E) * \u0027a * (Tree\u003C\u0027a\u003E)\n\n        // add instance for Foldable class\n        static member inline FoldMap (t:Tree\u003C_\u003E, f) =\n            let rec loop x f =\n                match x with\n                | Empty          -\u003E zero\n                | Leaf  n        -\u003E f n\n                | Node (l, k, r) -\u003E loop l f \u002B\u002B f k \u002B\u002B loop r f\n            loop t f\n        static member inline FoldBack (x:Tree\u003C_\u003E, f, z) = FoldBack.FromFoldMap f z x\n        static member inline ToSeq    (x:Tree\u003C_\u003E) = Tree\u003C_\u003E.FoldBack (x, (fun x y -\u003E seq {yield x; yield! y}), Seq.empty)\n    \n    let myTree = Node (Node (Leaf 1, 6, Leaf 3), 2 , Leaf 9)\n    let resSum21      = foldMap id   myTree\n    let resProduct324 = foldMap Mult myTree\n    let res21         = foldBack   (\u002B) myTree 0\n    let res21\u0027        = fold       (\u002B) 0 myTree    // \u003C- Tree.Fold is not defined but it fallbacks to the default method (Tree.ToSeq)\n\nmodule FoldableTree2 =\n    type Tree\u003C\u0027a\u003E =\n        | Empty \n        | Leaf of \u0027a \n        | Node of (Tree\u003C\u0027a\u003E) * \u0027a * (Tree\u003C\u0027a\u003E)\n\n        // add instance for Foldable abstraction (ToSeq is the minimal definition).\n        static member ToSeq x =        \n            let rec loop t = seq {\n                match t with\n                | Empty        -\u003E ()\n                | Leaf n       -\u003E yield n\n                | Node (l,k,r) -\u003E yield k; yield! loop l; yield! loop r}\n            loop x\n       \n        static member inline FoldBack (x, f, z) = \n            let rec _foldMap x f =\n                match x with\n                | Empty        -\u003E getZero()\n                | Leaf n       -\u003E f n\n                | Node (l,k,r) -\u003E plus (_foldMap l f) (plus (f k) (_foldMap r f))\n            Endo.run (_foldMap x (Endo \u003C\u003C f )) z\n\n    \n    let tree = Node (Node (Leaf 1, 6, Leaf 3), 2 , Leaf 9)\n    let res21  = foldBack   (\u002B) tree 0\n\n    // Following operations work by falling back to Tree.ToSeq which is the default\n    let res21\u0027 = fold   (\u002B) 0   tree      \n    let resTr  = exists ((=) 3) tree\n    let resS3  = tryPick (fun x -\u003E if x = 3 then Some x else None) tree"},{"uri":"/FSharpPlus/abstraction-traversable.html","title":"Traversable\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nTraversable\n===========\n\nData structures that can be traversed from left to right, performing an action on each element.\n\n___\n\n\n\nMinimal complete definition\n---------------------------\n\n\n * \u0060\u0060traverse f x\u0060\u0060 | \u0060\u0060sequence x\u0060\u0060\n*)\n(**\n    static member Traverse (t:\u0027Traversable\u003C\u0027T\u003E, f : \u0027T-\u003E\u0027Functor\u003C\u0027U\u003E) : \u0027Functor\u003C\u0027Traversable\u003C\u0027U\u003E\u003E\n    static member Sequence (t:\u0027Traversable\u003C\u0027Functor\u003C\u0027T\u003E\u003E) : \u0027Functor\u003C\u0027Traversable\u003C\u0027T\u003E\u003E\n*)\n(**\n\n\n\nRules\n-----\n*)\n(**\n    t \u003C\u003C traverse f = traverse (t \u003C\u003C f) \n    traverse Identity = Identity\n    traverse (Compose \u003C\u003C map g \u003C\u003C f) = Compose \u003C\u003C map (traverse g) \u003C\u003C traverse f\n*)\n(**\n\n\nRelated Abstractions\n--------------------\n\n - [Functor](abstraction-functor.html): A traversable is generic on the Traversable type parameter and the (Applicative) Functor inner type parameter.\n - [Applicative](abstraction-applicative.html): An applicative is a functor whose \u0060\u0060map\u0060\u0060 operation can be splitted in \u0060\u0060return\u0060\u0060 and \u0060\u0060(\u003C*\u003E)\u0060\u0060 operations. \n - [Foldable](abstraction-foldable.html) : All traversables are foldables.\n\n\nConcrete implementations\n------------------------\n\nFrom .Net/F#\n \n -  \u0060\u0060seq\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060list\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060array\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060option\u003C\u0027T\u003E\u0060\u0060 \n -  \u0060\u0060voption\u003C\u0027T\u003E\u0060\u0060 \n -  \u0060\u0060ResizeArray\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Map\u003C\u0027K, \u0027T\u003E\u0060\u0060\n -  \u0060\u0060Result\u003C\u0027T, \u0027Error\u003E\u0060\u0060\n -  \u0060\u0060Choice\u003C\u0027T, \u0027Error\u003E\u0060\u0060\n\n \nFrom F#\u002B\n\n -  [\u0060\u0060ZipList\u003C\u0027T\u003E\u0060\u0060](type-ziplist.html)\n -  [\u0060\u0060NonEmptyList\u003C\u0027T\u003E\u0060\u0060](type-nonempty.html)\n -  [\u0060\u0060NonEmptyMap\u003C\u0027Key, \u0027T\u003E\u0060\u0060](type-nonempty-map.html)\n -  [\u0060\u0060Validation\u003C\u0027Error,\u0027T\u003E\u0060\u0060](type-validation.html)\n\n\n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n\nExamples\n--------\n*)\n\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\n\n\n// Some functions\nlet getLine    = async { return System.Console.ReadLine() }\nlet f x = if x \u003C 200 then [3 - x] else []\nlet g x = if x \u003C 200 then Some (3 - x) else None\n\n// traverse\nlet resSomeminus100 = traverse f (Some 103)\nlet resLstOfNull    = traverse f None \nlet res210          = traverse f [1;2;3]  \nlet resSome210      = traverse g [1;2;3]  \nlet resEmptyList    = traverse f [1000;2000;3000] \nlet resEListOfElist = traverse f []\n\n// sequence\nlet resSome321  = sequence [Some 3;Some 2;Some 1]\nlet resNone     = sequence [Some 3;None  ;Some 1]\nlet res654      = (sequence [ (\u002B) 3 ; (\u002B) 2 ; (\u002B) 1]) 3\nlet resCombined = sequence [ [1;2;3] ; [4;5;6]  ]\nlet resLstOfArr = sequence [|[1;2;3] ; [4;5;6] |]  // \u003C- Uses the default method.\nlet resArrOfLst = sequence [[|1;2;3|];[|4;5;6 |]]\n\n// This computation will ask for three user inputs\n// try Async.RunSynchronously get3strings\nlet get3strings = sequence [getLine;getLine;getLine]"},{"uri":"/FSharpPlus/type-validation.html","title":"Validation\u003C\u0027Error, \u0027T\u003E\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nValidation\u003C\u0027Error, \u0027T\u003E\n======================\n\nThis is similar to Result\u003C\u0027T, \u0027Error\u003E but with accumulative errors semantics, instead of short-circuit.\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\nopen System\nopen FSharpPlus\nopen FSharpPlus.Data\n\nmodule MovieValidations =\n    type VError =\n        | MustNotBeEmpty\n        | MustBeAtLessThanChars of int\n        | MustBeADate\n        | MustBeOlderThan of int\n        | MustBeWithingRange of decimal * decimal\n\n    module String =\n        let nonEmpty (x:string) : Validation\u003CVError list, string\u003E =\n            if String.IsNullOrEmpty x\n            then Failure [MustNotBeEmpty]\n            else Success x\n        let mustBeLessThan (i: int) (x: string) : Validation\u003CVError list, string\u003E =\n            if isNull x || x.Length \u003E i\n            then Failure [MustBeAtLessThanChars i]\n            else Success x\n\n    module Number =\n        let mustBeWithin (from, to\u0027) x =\n            if from\u003C= x \u0026\u0026 x \u003C= to\u0027\n            then Success x\n            else Failure [MustBeWithingRange (from, to\u0027)]\n    \n    module DateTime =\n        let classicMovie year (d: DateTime) =\n            if d.Year \u003C year\n            then Success d\n            else Failure [MustBeOlderThan year]\n        let date (d: DateTime) =\n            if d.Date = d\n            then Success d\n            else Failure [MustBeADate]\n    \n    type Genre =\n        | Classic\n        | PostClassic\n        | Modern\n        | PostModern\n        | Contemporary\n    \n    type Movie = {\n        Id: int\n        Title: String\n        ReleaseDate: DateTime\n        Description: String\n        Price: decimal\n        Genre: Genre\n    } with\n        static member Create (id, title, releaseDate, description, price, genre) : Validation\u003CVError list, Movie\u003E =\n            fun title releaseDate description price -\u003E { Id = id; Title = title; ReleaseDate = releaseDate; Description = description; Price = price; Genre = genre }\n            \u003C!\u003E String.nonEmpty title \u003C* String.mustBeLessThan 100 title\n            \u003C*\u003E DateTime.classicMovie 1960 releaseDate \u003C* DateTime.date releaseDate\n            \u003C*\u003E String.nonEmpty description \u003C* String.mustBeLessThan 1000 description\n            \u003C*\u003E Number.mustBeWithin (0.0m, 999.99m) price\n\n    let newRelease = Movie.Create (1, \u0022Midsommar\u0022, DateTime (2019, 6, 24), \u0022Midsommar is a 2019 folk horror film written...\u0022, 1m, Classic) //Failure [MustBeOlderThan 1960]\n    let oldie = Movie.Create (2, \u0022Modern Times\u0022, DateTime (1936, 2, 5), \u0022Modern Times is a 1936 American comedy film...\u0022, 1m, Classic) // Success..\n    let titleToLong = Movie.Create (3, String.Concat (seq { 1..110 }), DateTime (1950, 1, 1), \u002211\u0022, 1m, Classic) //Failure [MustBeAtLessThanChars 100]\n\n\nmodule Person =\n\n    type Name = { unName: String }\n    with static member create s = {unName = s }\n\n    type Email = { unEmail: String } \n    with static member create s = { unEmail = s }\n\n    type Age = { unAge : int }\n    with static member create i = { unAge = i }\n\n    type Person = {\n        name: Name\n        email: Email\n        age: Age }\n    with static member create name email age = { name = name; email = email; age = age }\n\n\n    type Error = \n        | NameBetween1And50\n        | EmailMustContainAtChar\n        | AgeBetween0and120\n\n    // Smart constructors\n    let mkName s =\n        let l = length s\n        if (l \u003E= 1 \u0026\u0026 l \u003C= 50)\n        then Success \u003C| Name.create s\n        else Failure  [NameBetween1And50]\n\n    let mkEmail s =\n        if String.contains \u0027@\u0027 s\n        then Success \u003C| Email.create s\n        else Failure [EmailMustContainAtChar]\n\n    let mkAge a =\n        if (a \u003E= 0 \u0026\u0026 a \u003C= 120)\n        then Success \u003C| Age.create a\n        else Failure [AgeBetween0and120]\n\n    let mkPerson pName pEmail pAge =\n        Person.create\n        \u003C!\u003E mkName pName\n        \u003C*\u003E mkEmail pEmail\n        \u003C*\u003E mkAge pAge\n\n    // Examples\n\n    let validPerson = mkPerson \u0022Bob\u0022 \u0022bob@gmail.com\u0022 25\n    // Success ({name = {unName = \u0022Bob\u0022}; email = {unEmail = \u0022bob@gmail.com\u0022}; age = {unAge = 25}})\n\n    let badName = mkPerson \u0022\u0022 \u0022bob@gmail.com\u0022 25\n    // Failure [NameBetween1And50]\n\n    let badEmail = mkPerson \u0022Bob\u0022 \u0022bademail\u0022 25\n    // Failure [EmailMustContainAtChar]\n\n    let badAge = mkPerson \u0022Bob\u0022 \u0022bob@gmail.com\u0022 150\n    // Failure [AgeBetween0and120]\n\n    let badEverything = mkPerson \u0022\u0022 \u0022bademail\u0022 150\n    // Failure [NameBetween1And50;EmailMustContainAtChar;AgeBetween0and120]\n\n    open FSharpPlus.Lens\n    let asMaybeGood = validPerson ^? Validation._Success\n    // Some ({name = {unName = \u0022Bob\u0022}; email = {unEmail = \u0022bob@gmail.com\u0022}; age = {unAge = 25}})\n    let asMaybeBad = badEverything ^? Validation._Success\n    // None\n\n    let asResultGood = validPerson ^. Validation.isoValidationResult\n    // Ok ({name = {unName = \u0022Bob\u0022}; email = {unEmail = \u0022bob@gmail.com\u0022}; age = {unAge = 25}})\n\n    let asResultBad = badEverything ^. Validation.isoValidationResult\n    // Error [NameBetween1And50;EmailMustContainAtChar;AgeBetween0and120]\n\n\nmodule Email =\n\n    // ***** Types *****\n    type AtString = AtString of string\n    type PeriodString = PeriodString of string\n    type NonEmptyString = NonEmptyString of string\n\n    type Email = Email of string\n\n    type VError =\n        | MustNotBeEmpty\n        | MustContainAt\n        | MustContainPeriod\n\n    // ***** Base smart constructors *****\n    // String must contain an \u0027@\u0027 character\n    let atString (x: string) : Validation\u003CVError list, AtString\u003E =\n        if String.contains \u0027@\u0027 x then Success \u003C| AtString x\n        else Failure [MustContainAt]\n\n    // String must contain an \u0027.\u0027 character\n    let periodString (x: string) : Validation\u003CVError list, PeriodString\u003E =\n        if String.contains \u0027.\u0027 x\n        then Success \u003C| PeriodString x\n        else Failure [MustContainPeriod]\n\n    // String must not be empty\n    let nonEmptyString (x: string) : Validation\u003CVError list, NonEmptyString\u003E =\n        if not \u003C| String.IsNullOrEmpty x\n        then Success \u003C| NonEmptyString x\n        else Failure [MustNotBeEmpty]\n\n    // ***** Combining smart constructors *****\n    let email (x: string) : Validation\u003CVError list, Email\u003E =\n        result (Email x) \u003C*\n        nonEmptyString x \u003C*\n        atString       x \u003C*\n        periodString   x\n\n    // ***** Example usage *****\n    let success = email \u0022bob@gmail.com\u0022\n\n    // Success (Email \u0022bob@gmail.com\u0022)\n\n    let failureAt = email \u0022bobgmail.com\u0022\n    // Failure [MustContainAt]\n\n    let failurePeriod = email \u0022bob@gmailcom\u0022\n    // Failure [MustContainPeriod]\n\n\n    let failureAll = email \u0022\u0022\n    // Failure [MustNotBeEmpty;MustContainAt;MustContainPeriod]"},{"uri":"/FSharpPlus/type-seqt.html","title":"TO-DO Add some docs here !\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n(**\nTO-DO Add some docs here !\n=========================\n\nExamples\n--------\n*)\n\n\n#r @\u0022../../src/FSharpPlus/bin/Release/net45/FSharpPlus.dll\u0022\n\nopen FSharpPlus"},{"uri":"/FSharpPlus/type-writer.html","title":"Writer\u003C\u0027Monoid,\u0027T\u003E\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nWriter\u003C\u0027Monoid,\u0027T\u003E\n==================\n\nThe Writer monad is good way to introduce a log of a computation. \nIt gives you a different way of logging that can be useful when you want to be able to inspect the logged results.\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\nopen FSharpPlus\nopen FSharpPlus.Data\ntype LogEntry={msg:string}\nwith\n    static member create x = {msg = x}\n\nlet output x =  Writer.tell [LogEntry.create x]\n\nlet calc = monad {\n  do! output \u0022I\u0027m going to start a heavy computation\u0022 // start logging\n  let y = sum [1..100_000]\n  do! output (string y)\n  do! output \u0022The computation finished\u0022\n  return y // return the result of the computation\n}\n\nlet logs = Writer.exec calc\nlet (y,logs\u0027) = Writer.run calc\n\n(**\nThere are some performance implications around using a regular list, that\u0027s why you should use DList in these scenarios\n*)\n\nlet output\u0027 x =  Writer.tell \u003C| DList.ofSeq [LogEntry.create x]\n\nlet calc\u0027 = monad {\n  do! output\u0027 \u0022I\u0027m going to start a heavy computation\u0022 // start logging\n  let y = sum [1..100_000]\n  do! output\u0027 (string y)\n  do! output\u0027 \u0022The computation finished\u0022\n  return y // return the result of the computation\n}\n\nlet logs2 = Writer.exec calc\u0027\nlet (y\u0027,logs2\u0027) = Writer.run calc\u0027"},{"uri":"/FSharpPlus/abstraction-arrow.html","title":"Arrow\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n(**\nArrow\n=====\n\nArrow\u003C\u0027T, \u0027U\u003E represents a process that takes as input something of type \u0027T and outputs something of type \u0027U.\n\n___\n\n\n\nMinimal complete definition\n---------------------------\n\n\n * \u0060\u0060arr f\u0060\u0060 and  \u0060\u0060first f\u0060\u0060\n\n*)\n(**\n    static member Arr(f: \u0027T -\u003E \u0027U) : \u0027Arrow\u003C\u0027T, \u0027U\u003E\n    static member First (f: \u0027Arrow\u003C\u0027T, \u0027U\u003E) : \u0027Arrow\u003C(\u0027T * \u0027V),(\u0027U * \u0027V)\u003E\n*)\n(**\n\n\n\nOther operations\n----------------\n\n * \u0060\u0060second f\u0060\u0060\n*)\n(**\n    static member Second (f: \u0027Arrow\u003C\u0027T, \u0027U\u003E) : \u0027Arrow\u003C(\u0027V * \u0027T),(\u0027V * \u0027U)\u003E\n*)\n(**\n * \u0060\u0060(***) f g\u0060\u0060\n*)\n(**\n    static member \u0060\u0060***\u0060\u0060 (f : \u0027Arrow\u003C\u0027T1,\u0027U1\u003E) (g : \u0027Arrow\u003C\u0027T2,\u0027U2\u003E) : \u0027Arrow\u003C(\u0027T1 * \u0027T2),(\u0027U1 * \u0027U2)\u003E\n*)\n(**\n * \u0060\u0060(\u0026\u0026\u0026) f g\u0060\u0060\n*)\n(**\n    static member  (\u0026\u0026\u0026) (f : \u0027Arrow\u003C\u0027T,\u0027U1\u003E) (g : \u0027Arrow\u003C\u0027T,\u0027U2\u003E) : \u0027Arrow\u003C\u0027T,(\u0027U1 * \u0027U2)\u003E\n*)\n(**\n\n\n\nRules\n-----\n*)\n(**\n    arr id = id\n    arr (f \u003E\u003E\u003E g) = arr f \u003E\u003E\u003E arr g\n    first (arr f) = arr (first f)\n    first (f \u003E\u003E\u003E g) = first f \u003E\u003E\u003E first g\n    first f \u003E\u003E\u003E arr fst = arr fst \u003E\u003E\u003E f\n    first f \u003E\u003E\u003E arr (id *** g) = arr (id *** g) \u003E\u003E\u003E first f\n    first (first f) \u003E\u003E\u003E arr assoc = arr assoc \u003E\u003E\u003E first f\n\n    where assoc ((a,b),c) = (a,(b,c))\n*)\n(**\n\n\nConcrete implementations\n------------------------\n\nFrom .Net/F#\n \n -  \u0060\u0060\u0027T-\u003E\u0027U\u0060\u0060\n -  \u0060\u0060Func\u003C\u0027T,\u0027U\u003E\u0060\u0060\n\n \nFrom F#\u002B\n\n -  [\u0060\u0060Kleisli\u003C\u0027T, \u0027Monad\u003C\u0027U\u003E\u003E\u0060\u0060](type-kleisli.html)\n\n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n*)"},{"uri":"/FSharpPlus/extensions.html","title":"Extensions\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nExtensions\n=======================\nExtensions are what you probably expect: helper functions for existing types.\n \nThey are defined as modules with the same name as the types they operate on\nunder the FSharpPlus namespace, so can be accessed via:\n*)\nopen FSharpPlus\n\n(**\nSome functions are common across foldable types such as \u0060intercalate\u0060 on\nList, Array and Seq, and others are common across wrapping containers,\nsuch as \u0060map\u0060, \u0060bind\u0060 and \u0060apply\u0060 on List, Array, and Seq, but also Option and Result.\n\nConstruction:\n=============\nThe \u0060singleton\u0060 function is already defined for Seq, Array and List, but F#\u002B adds it for Enumerator:\n\n * Enumerator.singleton - construct a container with the given value inside it\n\nTo construct MonadError instances (Result or Choice) you can use result/throw:\n\n * Result.result / Choice.result - construct with the given value (as Ok or Choice1Of2)\n * Result.throw / Choice.throw - construct an error from the given value (as Error or Choice2of2)\n\nIt\u0027s also possible to construct by wrapping exception producing functions:\n\n * Option.protect - returns None on exception\n * Result.protect - returns Error with exception value on exception\n * Choice.protect - returns Choice2Of2 with exception value on exception\n*)\n// throws \u0022ArgumentException: The input sequence was empty.\u0022\nlet expectedSingleItem1 : int = List.exactlyOne []\n\n// returns a Result.Error holding the exception as its value:\nlet expectedSingleItem2 : Result\u003Cint,exn\u003E = Result.protect List.exactlyOne []\n\n// ...or like typical try prefixed functions, treat exception as None\nlet expectedSingleItem3 : Option\u003Cint\u003E = Option.protect List.exactlyOne []\n\n// which might look like this:\nlet inline tryExactlyOne xs = Option.protect List.exactlyOne xs\n\n(**\nDeconstruction (unwrapping):\n============================\nSome extensions on Result are designed to behave like Option:\n\n * Result.get - unwraps the value when it is an \u0027ok, otherwise throws an exception\n * Result.defaultValue - return the \u0027ok value if present, otherwise the default value\n * Result.defaultWith - return the \u0027ok value if present, otherwise apply the given function\n   to the \u0027error value\n\nTo deconstruct MonadError instances (Result or Choice) use:\n\n * Result.either - unwraps the result by applying the given \u0060ok\u0060 or \u0060err\u0060 function as appropriate\n * Choice.either - unwraps the choice by applying the given \u0060choice1\u0060 or \u0060choice2\u0060 function as appropriate\n\nNote that there is also the generic \u0060either\u0060 operator function that works\nexactly the same as \u0060Result.either\u0060.\n\nAlso, see the generic function [\u0060option\u0060](reference/fsharpplus-operators.html) that\nunwraps an Option in a similar way to \u0060either\u0060.\n\nOn Foldables\n============\nFoldables are the class of data structures that can be folded to a summary value.\nMost collections, or specifically \u0027foldable\u0027 instances implement these:\n\n * intersperse - takes an element and \u0060intersperses\u0027 that element between the elements\n\n*)\nlet a = [\u0022Bob\u0022; \u0022Jane\u0022] |\u003E List.intersperse \u0022and\u0022\n// vat a : string list = [\u0022Bob\u0022; \u0022and\u0022; \u0022Jane\u0022]\n\nlet b = \u0022WooHoo\u0022 |\u003E String.intersperse \u0027-\u0027\n// val b : string = \u0022W-o-o-H-o-o\u0022\n\n(**\n * intercalate - insert a list of elements between each element and flattens\n*)\nlet c = [[1;2]; [3;4]] |\u003E List.intercalate [-1;-2];;\n// val c : int list = [1; 2; -1; -2; 3; 4]\n\nlet d = [\u0022Woo\u0022; \u0022Hoo\u0022] |\u003E String.intercalate \u0022--o.o--\u0022;;\n// val d : string = \u0022Woo--o.o--Hoo\u0022\n\n(**\n * zip/unzip - tuple together values inside two containers, or untuble tupled values\n\nOn Monad/Functor/Applicatives\n=============================\nTypes that implement these will (typically) have these functions defined:\n\n * map - apply a mapping function to the value inside a container\n * bind - take a contained value, and apply a function that produces another contained value\n * apply - like map but where the mapping function is also inside a container\n\nThese can also be invoked from the generic functions without module prefix as per\n[generic functions \u0026 operators](reference/fsharpplus-operators.html).\n\nFlatten:\n========\nFlatten can be used when a container has another container inside it:\n\n * Choice.flatten\n * Result.flatten\n * Option.flatten (already defined in FSharp Core)\n\nNote that on traversable types like List, Array and Seq, FSharp Core uses the\nmore common \u0060concat\u0060 for flatten and so this naming is continued for Enumerable:\n\n * Enumerable.concat\n\nPartitioning:\n=============\nPartitioning can be done by applying a separating function that produces a Choice:\n\n * Array.partitionMap\n * List.partitionMap\n*)\nlet isEven x = (x % 2) = 0\nlet chooseEven x = if isEven x then Choice1Of2 x else Choice2Of2 x\n\nlet e = [1; 2; 3; 4] |\u003E List.partitionMap chooseEven\n// val e : int list * int list = ([2; 4], [1; 3])\n\n(**\nConversion functions:\n=====================\nF#\u002B adds functions to convert between Result, Choice and Option types.\n\nThese should be self explanatory, but be aware that sometimes they are \u0027lossy\u0027\nusually when converting to Option:\n*)\n(**\n// Convert a \u0060Result\u0060 to an \u0060Option\u0060 - effectively throws away error value\n// when present, by replacing with \u0060None\u0060\n\u0060\u0060\u0060f#\nrequest |\u003E validateRequest |\u003E Option.ofResult\n\u0060\u0060\u0060\n*)\n\n(**\nGoing the other way is similar, but a value needs to be filled in for None:\n*)\nlet xs = [\u0022some value\u0022]\nlet firstElementOption = xs |\u003E List.tryHead\n\n// Convert an \u0060Option\u0060 to a \u0060Result\u0060 will use unit as the Error:\nfirstElementOption |\u003E Option.toResult\n\n// ...but you can specify an error value with Option.toResultWith:\nfirstElementOption |\u003E Option.toResultWith \u0022No Element\u0022\n\n(**\nConverting between \u0060Choice\u0060 and \u0060Result\u0060 is often useful:\n\u0060\u0060\u0060f#\nlet asyncChoice = anAsyncValue |\u003E Async.Catch |\u003E Async.map Result.ofChoice\n\u0060\u0060\u0060\n*)\n\n(**\nThe String type:\n================\n\n * [ String ](reference/fsharpplus-string.html)\n   * intercalate, intersperse, \n   * split, replace\n   * isSubString, startsWith, endsWith, contains\n   * toUpper, toLower\n   * trimWhiteSpaces\n   * normalize\n   * removeDiacritics\n   * padLeft, padLeftWith, padRight, padRightWith\n   * trim, trimStart, trimEnd\n   * item, tryItem\n   * rev\n   * take, skip takeWhile, skipWhile\n   * truncate, drop\n   * findIndex, tryFindIndex\n   * findSliceIndex, tryFindSliceIndex\n   * toArray, ofArray, toList, ofList, toSeq, ofSeq, toCodePoints, ofCodePoints\n   * getBytes\n\nCollections / Traversable types:\n=================================\n * [Array](reference/fsharpplus-array.html)\n   * intercalate, intersperse,\n   * split, replace,\n   * findSliceIndex, trySliceIndex,\n   * partitionMap\n * [IList](reference/fsharpplus-ilist.html)\n   * toIReadOnlyList\n * [List](reference/fsharpplus-list.html)\n   * singleton,\n   * cons,\n   * apply,\n   * tails, take, skip, drop,\n   * intercalate, intersperse, \n   * split, replace,\n   * toIReadOnlyList,\n   * findSliceIndex, tryFindSliceIndex,\n   * partitionMap\n   * setAt, removeAt\n * [Enumerator](reference/fsharpplus-enumerator.html)\n   * EmptyEnumerator\n      * Empty - create an empty enumerator\n   * ConcatEnumerator\n      * concat\n   * MapEnumerators\n      * map, mapi, map2, mapi2, map3\n   * singleton\n   * tryItem, nth\n   * choose\n   * filter\n   * unfold\n   * upto\n   * zip, zip3\n * [ Seq ](reference/fsharpplus-seq.html)\n    * bind, apply, foldback\n    * chunkBy\n    * intersperse, intercalate,\n    * split, replace\n    * drop\n    * replicate\n    * toIReadOnlyList\n    * findSliceIndex, tryFindSliceIndex\n * [ IReadOnlyCollection ](reference/fsharpplus-ireadonlycollection.html)\n     * ofArray, ofList, ofSeq\n     * map\n * [ IReadOnlyList ](reference/fsharpplus-ireadonlylist.html)\n   * ofArray, toArray\n   * trySetItem, tryItem\n * [ Map ](reference/fsharpplus-map.html)\n   * keys, values\n   * mapValues, mapValues2\n   * zip, unzip\n   * unionWith, union, intersectWith, intersect\n * [ Dict ](reference/fsharpplus-dict.html)\n   * toIReadOnlyDictionary\n   * tryGetValue\n   * containsKey\n   * keys, values\n   * map, map2\n   * zip, unzip\n   * unionWith, union, intersectWith, intersect\n * [ IReadOnlyDictionary ](reference/fsharpplus-ireadonlydictionary.html)\n   * add, \n   * tryGetValue, containsKey,\n   * keys, values,\n   * map, map2, \n   * zip, unzip, \n   * unionWith, union, intersectWith, intersect\n\nAsync, Task and ValueTask:\n==========================\n * [ Task ](reference/fsharpplus-task.html)\n   * map, map2, map3\n   * apply\n   * zip\n   * join\n   * ignore\n * [ ValueTask ](reference/fsharpplus-valueTask.html)\n   * map, map2, map3\n   * apply\n   * zip\n   * join\n   * ignore\n * [ Async ](reference/fsharpplus-async.html)\n   * map, map2\n   * zip\n   * join\n   * apply\n   * raise\n\nOption, Choice and Result types:\n================================\n * [Option](reference/fsharpplus-option.html)\n   * apply, \n   * unzip, zip,\n   * toResult, toResultWith, ofResult, \n   * protect\n * [Choice](reference/fsharpplus-choice.html)\n   * result, throw - construct a Choice\n   * bind, apply, flatten,\n   * map,\n   * catch, - deprecated\n   * bindChoice2Of2,\n   * either,\n   * protect\n * [ Result ](reference/fsharpplus-result.html)\n   * result, throw - construct a Result\n   * apply, (map, bind already defined)\n   * flatten,\n   * bindError,\n   * either,\n   * protect,\n   * get,\n   * defaultValue, defaultWith,\n   * toChoice, ofChoice,\n   * partition\n\nExtensions Methods (on existing types):\n=======================================\nThese are usable from C#\n\n * [ Extension Methods ](extension-methods.html)\n   * IEnumerable\u003C\u0027T\u0027\u003E.GetSlice\n   * List\u003C\u0027T\u003E.GetSlice\n   * Task\u003C\u0027T\u003E.WhenAll\n   * Async.Sequence - of seq, list or array\n   * Option.Sequence - of seq\n\n*)"},{"uri":"/FSharpPlus/type-dlist.html","title":"DList\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nDList\n=========================\n\nDList is an ordered linear structure implementing the List signature (head, tail, cons), \nend-insertion (add), and O(1) append. Ordering is by insertion history.\nDList is an implementation of [John Hughes\u0027 append list](http://dl.acm.org/citation.cfm?id=8475).\n\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\nopen FSharpPlus.Data\n\n(**\n### Constructing DLists\n*)\n// you can construct a DList by using ofSeq\nlet list123 = DList.ofSeq [ 1; 2; 3 ]\n\nlet listEmpty = DList.empty\n// cons\nlet list2 = DList.cons 100 list123 \n// append two DLists\nlet list3 = DList.append list2 (DList.singleton 200)\n// this can be written as (since list2 is a DList):\nlet list3\u0027 = plus list2 (result 200)\n// in order to get back to a regular list you can then use toList:\nlet list4 = toList list3\u0027\n\n(**\n### Operations on DList\n*)\n\nlet lengthOfList3 = DList.length list3\nlet lengthOfList3\u0027 = length list3\n\nlet headOf3 = DList.head list3 \nlet headOf3\u0027 = head list3 "},{"uri":"/FSharpPlus/abstraction-functor.html","title":"Functor\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nFunctor\n=======\nThe Functor abstraction is used for types that can be mapped over.\n___\nMinimal complete definition\n---------------------------\n * \u0060\u0060map f x\u0060\u0060/\u0060\u0060(|\u003E\u003E) x f\u0060\u0060/\u0060\u0060(\u003C\u003C|) f x\u0060\u0060/\u0060\u0060(\u003C!\u003E) f x\u0060\u0060\n*)\n(**\n    static member Map (x:\u0027Functor\u003C\u0027T\u003E, f:\u0027T-\u003E\u0027U) :\u0027Functor\u003C\u0027U\u003E\n*)\n(**\nOther operations\n----------------\n * \u0060\u0060unzip x\u0060\u0060\n*)\n(**\n    static member Unzip (x:Functor\u003C\u0027T * \u0027U\u003E) :\u0027Functor\u003C\u0027T\u003E * \u0027Functor\u003C\u0027U\u003E\n*)\n(**\nRules\n-----\n*)\n(**\n    map id  =  id\n    map (f \u003C\u003C g) = map f \u003C\u003C map g\n*)\n(**\nRelated Abstractions\n--------------------\n - [Applicative](abstraction-applicative.html): An applicative is a functor whose \u0060\u0060map\u0060\u0060 operation can be splitted in \u0060\u0060return\u0060\u0060 and \u0060\u0060(\u003C*\u003E)\u0060\u0060 operations,\n \n - [Monad](abstraction-monad.html) : Monads are functors with an additional \u0060\u0060Join\u0060\u0060 operation,\nConcrete implementations\n------------------------\nFrom F#\n \n -  \u0060\u0060seq\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060list\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060array\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060\u0027T [,]\u0060\u0060\n -  \u0060\u0060\u0027T [,,]\u0060\u0060\n -  \u0060\u0060\u0027T [,,,]\u0060\u0060\n -  \u0060\u0060option\u003C\u0027T\u003E\u0060\u0060 \n -  \u0060\u0060voption\u003C\u0027T\u003E\u0060\u0060 \n -  \u0060\u0060IObservable\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Lazy\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Async\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Result\u003C\u0027T,\u0027U\u003E\u0060\u0060\n -  \u0060\u0060Choice\u003C\u0027T,\u0027U\u003E\u0060\u0060\n -  \u0060\u0060KeyValuePair\u003C\u0027Key,\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Map\u003C\u0027Key,\u0027T\u003E\u0060\u0060\n -  \u0060\u0060\u0027Monoid * \u0027T\u0060\u0060\n -  \u0060\u0060\u0027struct (\u0027Monoid * \u0027T)\u0060\u0060\n -  \u0060\u0060Task\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060ValueTask\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060\u0027R-\u003E\u0027T\u0060\u0060\n -  \u0060\u0060Expr\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060Dictionary\u003C\u0027Key,\u0027T\u003E\u0060\u0060\n -  \u0060\u0060IDictionary\u003C\u0027Key,\u0027T\u003E\u0060\u0060\n -  \u0060\u0060IReadOnlyDictionary\u003C\u0027Key,\u0027T\u003E\u0060\u0060\n -  \u0060\u0060ResizeArray\u003C\u0027T\u003E\u0060\u0060\n \nFrom F#\u002B\n\n -  [\u0060\u0060Cont\u003C\u0027R,\u0027T\u003E\u0060\u0060](type-cont.html)\n -  [\u0060\u0060ContT\u003C\u0027R,\u0027T\u003E\u0060\u0060](type-contt.html)\n -  [\u0060\u0060Reader\u003C\u0027R,\u0027T\u003E\u0060\u0060](type-reader.html)\n -  [\u0060\u0060ReaderT\u003C\u0027R,\u0027Monad\u003C\u0027T\u003E\u003E\u0060\u0060](type-readert.html)\n -  [\u0060\u0060Writer\u003C\u0027Monoid,\u0027T\u003E\u0060\u0060](type-writer.html)\n -  [\u0060\u0060WriterT\u003C\u0027Monad\u003C\u0027T * \u0027Monoid\u003E\u003E\u0060\u0060](type-writert.html)\n -  [\u0060\u0060State\u003C\u0027S,\u0027T * \u0027S\u003E\u0060\u0060](type-state.html)\n -  [\u0060\u0060StateT\u003C\u0027S,\u0027Monad\u003C\u0027T * \u0027S\u003E\u003E\u0060\u0060](type-statet.html)\n -  [\u0060\u0060OptionT\u003C\u0027Monad\u003Coption\u003C\u0027T\u003E\u003E\u0060\u0060](type-optiont.html)\n -  [\u0060\u0060ValueOptionT\u003C\u0027Monad\u003Cvoption\u003C\u0027T\u003E\u003E\u0060\u0060](type-valueoptiont.html)\n -  [\u0060\u0060SeqT\u003C\u0027Monad\u003Cseq\u003C\u0027T\u003E\u003E\u0060\u0060](type-seqt.html)\n -  [\u0060\u0060ListT\u003C\u0027Monad\u003Clist\u003C\u0027T\u003E\u003E\u0060\u0060](type-listt.html)\n -  [\u0060\u0060ResultT\u003C\u0027Monad\u003CResult\u003C\u0027T,\u0027TError\u003E\u003E\u0060\u0060](type-resultt.html)\n -  [\u0060\u0060ChoiceT\u003C\u0027Monad\u003CChoice\u003C\u0027T,\u0027TError\u003E\u003E\u0060\u0060](type-choicet.html)\n -  [\u0060\u0060Free\u003C\u0027Functor\u003C\u0027T\u003E,\u0027T\u003E\u0060\u0060](type-free.html)\n -  [\u0060\u0060NonEmptyList\u003C\u0027T\u003E\u0060\u0060](type-nonempty.html)\n -  [\u0060\u0060NonEmptySet\u003C\u0027T\u003E\u0060\u0060](type-nonempty-set.html)\n -  [\u0060\u0060NonEmptyMap\u003C\u0027Key, \u0027T\u003E\u0060\u0060](type-nonempty-map.html)\n -  [\u0060\u0060Validation\u003C\u0027Error,\u0027T\u003E\u0060\u0060](type-validation.html)\n -  [\u0060\u0060ZipList\u003C\u0027T\u003E\u0060\u0060](type-ziplist.html)\n -  [\u0060\u0060ParallelArray\u003C\u0027T\u003E\u0060\u0060](type-parallelarray.html)\n -  [\u0060\u0060Const\u003C\u0027C,\u0027T\u003E\u0060\u0060](type-const.html)\n -  [\u0060\u0060Compose\u003C\u0027AlternativeF\u003C\u0027AlternativeG\u003C\u0027T\u003E\u003E\u003E\u0060\u0060](type-compose.html)\n -  [\u0060\u0060DList\u003C\u0027T\u003E\u0060\u0060](type-dlist.html)\n -  [\u0060\u0060Kleisli\u003C\u0027T, \u0027Monad\u003C\u0027U\u003E\u003E\u0060\u0060](type-kleisli.html)\n -  [\u0060\u0060Coproduct\u003C\u0027FunctorL\u003C\u0027T\u003E,\u0027FunctorR\u003C\u0027T\u003E\u003E\u0060\u0060](type-coproduct.html)\n -  [\u0060\u0060Vector\u003C\u0027T,\u0027Dimension\u003E\u0060\u0060](type-vector.html)\n -  [\u0060\u0060Matrix\u003C\u0027T,\u0027Rows,\u0027Columns\u003E\u0060\u0060](type-matrix.html)\n\nRestricted:\n -  \u0060\u0060string\u0060\u0060\n -  \u0060\u0060StringBuilder\u0060\u0060\n -  \u0060\u0060Set\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060IEnumerator\u003C\u0027T\u003E\u0060\u0060\n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\nopen FSharpPlus.Math.Generic\n\nlet getLine    = async { return System.Console.ReadLine() }\nlet putStrLn x = async { printfn \u0022%s\u0022 x}\nlet print    x = async { printfn \u0022%A\u0022 x}\n\n// Test IO\nlet action = monad {\n    do! putStrLn  \u0022What is your first name?\u0022\n    let! fn = getLine\n    do! putStrLn  (\u0022Thanks, \u0022 \u002B fn) \n    do! putStrLn  (\u0022What is your last name?\u0022)\n    let! ln = getLine\n    let  fullname = fn \u002B \u0022 \u0022 \u002B ln\n    do! putStrLn  (\u0022Your full name is: \u0022 \u002B fullname)\n    return fullname }\n\n\n// Test Functors\nlet times2,minus3 = (*) 2, (-)/\u003E 3\nlet resSome1      = map minus3 (Some 4G)\nlet noValue       = map minus3 None\nlet lstTimes2     = map times2 [1;2;3;4]\nlet fTimes2minus3 = map minus3 times2\nlet res39         = fTimes2minus3 21G\nlet getChars      = map (fun (x:string) -\u003E x.ToCharArray() |\u003E Seq.toList ) action\nlet quot7         = map ((\u002B)2) \u003C@ 5 @\u003E\n\n\n// try -\u003E runIO getChars ;;\n\n// Define a type Tree\ntype Tree\u003C\u0027a\u003E =\n    | Tree of \u0027a * Tree\u003C\u0027a\u003E * Tree\u003C\u0027a\u003E\n    | Leaf of \u0027a\n    static member map f (t:Tree\u003C\u0027a\u003E  )  =\n        match t with\n        | Leaf x -\u003E Leaf (f x)\n        | Tree(x,t1,t2) -\u003E Tree(f x, Tree.map f t1, Tree.map f t2)\n\n// add instance for Functor class\n    static member Map (x:Tree\u003C_\u003E, f) = Tree.map f x\n\nlet myTree = Tree(6, Tree(2, Leaf 1, Leaf 3), Leaf 9)\nlet mappedTree = map fTimes2minus3 myTree\n\n\n\n// An Applicative is automatically a Functor\n\ntype ZipList\u003C\u0027s\u003E = ZipList of \u0027s seq with\n    static member Return (x:\u0027a)     = ZipList (Seq.initInfinite (konst x))\n    static member (\u003C*\u003E) (ZipList (f:seq\u003C\u0027a-\u003E\u0027b\u003E), ZipList x) = ZipList (Seq.zip f x |\u003E Seq.map (fun (f, x) -\u003E f x)) : ZipList\u003C\u0027b\u003E\n\nlet mappedZipList = map string (ZipList [1;2;3])\n\n\n// A Monad is automatically a Functor\n\ntype MyList\u003C\u0027s\u003E = MyList of \u0027s seq with\n    static member Return (x:\u0027a)     = MyList x\n    static member (\u003E\u003E=)  (MyList x: MyList\u003C\u0027T\u003E, f) = MyList (Seq.collect (f \u003E\u003E (fun (MyList x) -\u003E x)) x)\n\nlet mappedMyList = map string (MyList [1;2;3])"},{"uri":"/FSharpPlus/abstraction-bifunctor.html","title":"Bifunctor\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n(**\nBifunctor\n=======\n\nIntuitively a bifunctor is a functor with 2 arguments which are covariant.\n\n___\n\nA bifunctor (short for binary functor) or functor of two variables is simply a functor whose domain is the product of two types.\n\n\nMinimal complete definition\n---------------------------\n\n\n * \u0060\u0060bimap f g x\u0060\u0060\n*)\n(**\n    static member Bimap (x:\u0027Bifunctor\u003C\u0027T,\u0027V\u003E, f:\u0027T-\u003E\u0027U, g:\u0027V-\u003E\u0027W) :\u0027Bifunctor\u003C\u0027U,\u0027W\u003E\n*)\n(**\n\n\nOther operations\n----------------\n\n * \u0060\u0060first f x\u0060\u0060\n*)\n(**\n    static member First (x:Bifunctor\u003C\u0027T,\u0027V\u003E, f:\u0027T-\u003E\u0027U) :\u0027Bifunctor\u003C\u0027U,\u0027V\u003E\n*)\n(**\n\n * \u0060\u0060second g x\u0060\u0060\n*)\n(**\n    static member Map (x:Bifunctor\u003C\u0027T,\u0027V\u003E, f:\u0027V-\u003E\u0027W) :\u0027Bifunctor\u003C\u0027T,\u0027W\u003E\n*)\n(**\n\n\n\n\nRules\n-----\n*)\n(**\n    bimap f g = first f \u003C\u003C second g\n*)\n(**\n\n\nRelated Abstractions\n--------------------\n\n - [Functor](abstraction-functor.html): All bifunctors are also functors over the second parameter.\n\n\nConcrete implementations of Bifunctor\u003C\u0027T1,\u0027T2\u003E\n-----------------------------------------------\n\nFrom .Net/F#\n \n -  \u0060\u0060\u0027T1 * \u0027T2\u0060\u0060\n -  \u0060\u0060struct (\u0027T1 * \u0027T2)\u0060\u0060\n -  \u0060\u0060Result\u003C\u0027T2,\u0027T1\u003E\u0060\u0060\n -  \u0060\u0060Choice\u003C\u0027T2,\u0027T1\u003E\u0060\u0060\n -  \u0060\u0060KeyValuePair\u003C\u0027T1,\u0027T2\u003E\u0060\u0060\n\n \nFrom F#\u002B\n\n -  [\u0060\u0060Const\u003C\u0027C,\u0027T\u003E\u0060\u0060](type-const.html)\n -  [\u0060\u0060Validation\u003C\u0027Error,\u0027T\u003E\u0060\u0060](type-validation.html)\n\n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n\nExamples\n--------\n*)\n\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\n\n// convert (map) first element to an int and the second to a string\nlet rInt10Str10 = bimap  int string (10.0, 10)\n\n\nlet resOk11  = bimap  ((\u002B) 1) string (Ok 10)\nlet rStrTrue = first  string (true, 10)\nlet rStr10   = second string (true, 10)"},{"uri":"/FSharpPlus/type-compose.html","title":"Compose\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nCompose\n=======\n\nAllows to compose applicatives and functors.\n\nIt worth noting that:\n\n - A composition of 2 functors is a functor\n - A composition of 2 applicatives is an applicative\n - A composition of 2 monads is not always a monad\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen FSharpPlus\nopen FSharpPlus.Data\n\n// First let\u0027s create some values\n\nlet (one : Async\u003CResult\u003Cint, string\u003E\u003E) = async { return Ok 1 }\nlet (two : Async\u003CResult\u003Cint, string\u003E\u003E) = async { return Ok 2 }\n\n// Now we can combine then\n\nlet (Compose three) = Compose (async {return Ok (\u002B)}) \u003C*\u003E Compose one \u003C*\u003E Compose two\n// val three : Async\u003CFSharpPlus.Result\u003Cint,string\u003E\u003E\n\n// or shorter\n\nlet (Compose three\u0027) = (\u002B) \u003C!\u003E Compose one \u003C*\u003E Compose two\n// val three\u0027 : Async\u003CFSharpPlus.Result\u003Cint,string\u003E\u003E"},{"uri":"/FSharpPlus/abstraction-contravariant.html","title":"Contravariant\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\n\n(**\nContravariant\n=============\n\nA Contravariant Functor can be mapped over the input.\n\n___\n\nOne can think of a [Functor](abstraction-functor.html) as containing or producing values, a contravariant functor is a functor that can be thought of as consuming values.\n\nMinimal complete definition\n---------------------------\n\n\n * \u0060\u0060contramap f x\u0060\u0060\n*)\n(**\n    static member Contramap (x:\u0027Contravariant\u003C\u0027T\u003E, f:\u0027U-\u003E\u0027T) :\u0027Contravariant\u003C\u0027U\u003E\n*)\n(**\n\n\n\n\nRules\n-----\n*)\n(**\n    contramap id = id\n    contramap f \u003C\u003C contramap g = contramap (g \u003C\u003C f)\n*)\n(**\n\n\nRelated Abstractions\n--------------------\n\n - [Functor](abstraction-functor.html): A Covariant Functor.\n \n - [Profunctor](abstraction-profunctor.html) : A profunctor is a bifunctor that is contravariant in the first argument and covariant in the second.\n\n\nConcrete implementations\n------------------------\n\nFrom .Net/F#\n \n -  \u0060\u0060(\u0027T -\u003E \u0027U)\u0060\u0060\n -  \u0060\u0060Predicate\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060IComparer\u003C\u0027T\u003E\u0060\u0060\n -  \u0060\u0060IEqualityComparer\u003C\u0027T\u003E\u0060\u0060\n\n \nFrom F#\u002B\n\n -  [\u0060\u0060Const\u003C\u0027C,\u0027T\u003E\u0060\u0060](type-const.html)\n\n [Suggest another](https://github.com/fsprojects/FSharpPlus/issues/new) concrete implementation\n\nExamples\n--------\n*)\n\n(**\n\u0060\u0060\u0060f#\n#r @\u0022nuget: FSharpPlus\u0022\n\u0060\u0060\u0060\n*)\n\nopen System\nopen FSharpPlus\n\n\nmodule Predicate = let run (p: Predicate\u003C_\u003E) x = p.Invoke (x)\n\nlet intToString (x:int) = string x\nlet resStr54 = contramap (fun (x:float) -\u003E int x) intToString \u003C| 54.\nlet isEven      = Predicate (fun x -\u003E x % 2 = 0)\nlet fstIsEven   = contramap List.head isEven\nlet resBoolTrue = Predicate.run fstIsEven [0..10]\n\ntype Person = Person of string\nlet personEqComp = HashIdentity.Structural\u003CPerson\u003E\nlet personList = [1, Person \u0022me\u0022; 2, Person \u0022you\u0022; 3, Person \u0022you\u0022]\nlet cnt3 = Seq.length \u003C| Linq.Enumerable.Distinct (personList)\nlet cnt2 = Seq.length \u003C| Linq.Enumerable.Distinct (personList, contramap snd personEqComp)\n\n(**\nFor instance a predicate function from a type to bool. An example of such a function is the predicate that classifies \nintegers as negative: \n*)\nlet negative = Predicate( fun integer -\u003E integer \u003C 0 )\n(**\n\nHowever, given this predicate, we can re-use it in other situations, providing we have a way to map values to integers. \nFor instance, we can use the \u0060negative\u0060 predicate on a person\u0027s bank balance to work out if they are currently overdrawn.\n*)\nlet personBankBalance (person:Person) : int = failwith \u0022query persons bank account\u0022 \nlet overdrawn = contramap personBankBalance negative"},{"uri":"/FSharpPlus/numerics.html","title":"Numeric functions\n","content":"(*** hide ***)\n// This block of code is omitted in the generated HTML documentation. Use \n// it to define helpers that you do not want to show in the documentation.\n#r @\u0022../../src/FSharpPlus/bin/Release/netstandard2.0/FSharpPlus.dll\u0022\nopen FSharpPlus\n\n(**\nNumeric functions\n=================\n\nThis library comes with some additional numeric functions and constants.\n\nThese functions work over many numeric types\n\n*)\n\nlet qr0  = divRem 7  3  //val qr0 : int * int = (2, 1)\nlet qr1  = divRem 7I 3I //val qr1 : System.Numerics.BigInteger * System.Numerics.BigInteger = (2, 1)\nlet qr2  = divRem 7. 3. //val qr2 : float * float = (2.333333333, 0.0) -\u003E using default method.\n\n(**\n\nNumeric constants\n=================\n\nApart from typical math constants, bounded types comes with \u003Ccode\u003EminValue\u003C/code\u003E and \u003Ccode\u003EmaxValue\u003C/code\u003E constants.\n\nHere\u0027s an example how can this be used to implement an efficient \u003Ccode\u003EfindMin\u003C/code\u003E function\n\n*)\n\nlet inline findMin (lst: \u0027a list) =\n    let rec loop acc = function\n        | [] -\u003E acc\n        | x::_ when x = minValue -\u003E x\n        | x::xs -\u003E loop (if x \u003C acc then x else acc) xs\n    loop maxValue lst\n    \nlet minInt  = findMin [1;0;12;2]\nlet minUInt = findMin [1u;0u;12u;2u]  // loops only twice\n\n\n(**\nGeneric operations over numeric types\n=====================================\n\n*)\n\n(**\n\nWriting code that is generic over different numeric types can be really tedious in F#.\n\nUsing this library it becomes an easy task, but it\u0027s important to understand the numeric abstractions and its limitations.\n\nIn order to have a reasonable type inference over generic types we need strict operations.\n\nFor example the F# definition of \u003Ccode\u003E(\u002B)\u003C/code\u003E can take 2 different types, this makes possible to interact with some .NET types that have defined the \u003Ccode\u003E(\u002B)\u003C/code\u003E operator in a very arbitrary way.\n\nFor instance you can add a \u003Ccode\u003Efloat\u003C/code\u003E to a \u003Ccode\u003EDateTime\u003C/code\u003E with the \u003Ccode\u003E(\u002B)\u003C/code\u003E operator, and that \u003Ccode\u003Efloat\u003C/code\u003E will be interpreted as seconds.\n\nBy opening the \u003Ccode\u003EFSharpPlus.Math.Generic\u003C/code\u003E namespace this will no longer be possible, because that\u0027s the tradeoff in order to get decent type inference.\n\n\n\nGeneric number literals\n=======================\n\nNumbers with a G suffix are generics.\n\n*)\n\nopen FSharpPlus.Math.Generic\n\nlet res5Int  : int    = 5G\nlet res5UInt : uint32 = 5G\n\n(**\nOften you need to define generic constants when defining generic functions.\nSince there is no way to define generic decimal literals in F# at the moment of writing this, we can use divisions:\n*)\n\n\nlet inline areaOfCircle radio =\n    let pi = \n        314159265358979323846264338G \n                    / \n        100000000000000000000000000G\n    pi * radio * radio\n\nlet area1 = areaOfCircle 5.\nlet area2 = areaOfCircle 5.0f\nlet area3 = areaOfCircle 5.0M\n\n\n\n(**\nDefining custom types, support generic operations\n=================================================\n*)\n\ntype Vector2d\u003C\u0027T\u003E = Vector2d of \u0027T * \u0027T  with\n    static member inline (\u002B) (Vector2d(a:\u0027t, b:\u0027t), Vector2d(c:\u0027t, d:\u0027t)) = Vector2d (((a \u002B c):\u0027t), ((b \u002B d):\u0027t))\n    static member inline (-) (Vector2d(a:\u0027t, b:\u0027t), Vector2d(c:\u0027t, d:\u0027t)) = Vector2d (((a - c):\u0027t), ((b - d):\u0027t))\n    static member inline (*) (Vector2d(a:\u0027t, b:\u0027t), Vector2d(c:\u0027t, d:\u0027t)) = Vector2d (((a * c):\u0027t), ((b * d):\u0027t))\n    static member        Return x                               = Vector2d (x, x)\n    static member        Map(Vector2d(x, y), f)                 = Vector2d (f x, f y)\n    static member inline FromBigInt x = let y = fromBigInt x in Vector2d (y, y)\n\n(**\nNote we don\u0027t define overloads for adding a vector to a number\n\nWhy? Apart from being tedious they will break math operators strictness \n\nso we will have problems type inferencing generic functions.\n\nOK, but then how to add (subtract, multiply) to a number?\n\n\n\nOption 1, explicitely \u0027lift\u0027 the number.\n\nRequires Return and ( \u002B , - , * )\n\n*)\n\nlet x1  = Vector2d (32,5) \u002B result 7\nlet x1\u0027 = result 7 \u002B Vector2d (32,5)\n\n(**\nOption 2, use Generic Numbers\n\nRequires \u003Ccode\u003EFromBigInt\u003C/code\u003E and (\u002B,-,*,/)\n*)\n\nopen FSharpPlus.Math.Generic\nlet x2  = Vector2d (32,5) \u002B 7G\nlet x2\u0027 = 7G \u002B Vector2d (32,5)\n\n(**\nOption 3, use Applicative Math Operators\nRequires only \u003Ccode\u003EMap\u003C/code\u003E\n*)\n\nopen FSharpPlus.Math.Applicative\nlet x3 = Vector2d (32,5) .\u002B 7\nlet x3\u0027 = 7 \u002B. Vector2d (32,5)\n\n\n(**\nIntegrate with 3rd party libraries\n==================================\n\nWe may use types defined in other libraries, let\u0027s suppose we have this type Ratio defined somewhere.\n*)\n\ntype Ratio =\n    struct\n        val Numerator   : bigint\n        val Denominator : bigint\n        new (numerator: bigint, denominator: bigint) = {Numerator = numerator; Denominator = denominator}\n    end\n    override this.ToString() = this.Numerator.ToString() \u002B \u0022 % \u0022 \u002B this.Denominator.ToString()\n\nlet ratio (a:bigint) (b:bigint) :Ratio =\n    if b = 0I then failwith \u0022Ratio.%: zero denominator\u0022\n    let a, b = if b \u003C 0I then (-a, -b) else (a, b)\n    let gcd = gcd a b\n    Ratio (a / gcd, b / gcd)\n\nlet Ratio (x,y) = x \u003C/ratio/\u003E y\n\ntype Ratio with\n    static member inline (/) (a:Ratio, b:Ratio) = (a.Numerator * b.Denominator) \u003C/ratio/\u003E (a.Denominator * b.Numerator)                                              \n    static member inline (\u002B) (a:Ratio, b:Ratio) = (a.Numerator * b.Denominator \u002B b.Numerator * a.Denominator) \u003C/ratio/\u003E (a.Denominator * b.Denominator)\n    static member inline (-) (a:Ratio, b:Ratio) = (a.Numerator * b.Denominator - b.Numerator * a.Denominator) \u003C/ratio/\u003E (a.Denominator * b.Denominator)\n    static member inline (*) (a:Ratio, b:Ratio) = (a.Numerator * b.Numerator) \u003C/ratio/\u003E (a.Denominator * b.Denominator)\n\n    static member inline Abs        (r:Ratio) = (abs    r.Numerator) \u003C/ratio/\u003E r.Denominator\n    static member inline Signum     (r:Ratio) = (signum r.Numerator) \u003C/ratio/\u003E 1I\n    static member inline FromBigInt (x:bigint) = fromBigInt x \u003C/ratio/\u003E 1I\n    static member inline (~-)       (r:Ratio) = -(r.Numerator) \u003C/ratio/\u003E r.Denominator\n\n(**\nSince most Rational implementations have Numerator and Denominator defined we can just use our generic functions on it:\n*)\n\nlet some3_2 = trySqrt (Ratio(9I, 4I))\n\n\n(**\n\nExample: creating a polymorphic quadratic function\n==================================================\n\nThe quadratic function has different results depending on which domain it operates.\n\nFor example for real numbers it can have 0 or 2 solutions (arguably also 1 that is a double solution).\n\nBut for complex numbers it always has 2 solutions.\n\n*)\n\nopen FSharpPlus.Math.Generic\n\nlet inline quadratic a b c =\n    let root1 = ( -b \u002B sqrt (  b * b - 4G * a * c) )  / (2G * a)\n    let root2 = ( -b - sqrt (  b * b - 4G * a * c) )  / (2G * a)\n    (root1,root2)\n\n\nlet noRes  = quadratic 2.0  3G 9G\n// val noRes : float * float = (nan, nan)\n\nlet res30_15  = quadratic 2.0  -3G -9G\n// val res30_15 : float * float = (3.0, -1.5)\n\nlet res30_15f = quadratic 2.0f -3G -9G\n// val res30_15f : float32 * float32 = (3.0f, -1.5f)\n\nlet resCmplx:System.Numerics.Complex * _ = quadratic 2G -3G 9G\n// val resCmplx : System.Numerics.Complex * System.Numerics.Complex = ((0.75, -1.98431348329844), (0.75, 1.98431348329844))\n\nlet res30_15r:Ratio * _ = quadratic 2G -3G -9G\n// val res30_15r : Ratio * Ratio = (3 % 1, -3 % 2)"}]